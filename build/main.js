/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@lwc/engine-dom/dist/engine-dom.cjs.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lwc/engine-dom/dist/engine-dom.cjs.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* proxy-compat-disable */\n\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction invariant(value, msg) {\n    if (!value) {\n        throw new Error(`Invariant Violation: ${msg}`);\n    }\n}\nfunction isTrue$1(value, msg) {\n    if (!value) {\n        throw new Error(`Assert Violation: ${msg}`);\n    }\n}\nfunction isFalse$1(value, msg) {\n    if (value) {\n        throw new Error(`Assert Violation: ${msg}`);\n    }\n}\nfunction fail(msg) {\n    throw new Error(msg);\n}\n\nvar assert = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    fail: fail,\n    invariant: invariant,\n    isFalse: isFalse$1,\n    isTrue: isTrue$1\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { assign, create, defineProperties, defineProperty, freeze, getOwnPropertyDescriptor: getOwnPropertyDescriptor$1, getOwnPropertyNames: getOwnPropertyNames$1, getPrototypeOf: getPrototypeOf$1, hasOwnProperty: hasOwnProperty$1, isFrozen, keys, seal, setPrototypeOf, } = Object;\nconst { isArray: isArray$1 } = Array;\nconst { concat: ArrayConcat$1, copyWithin: ArrayCopyWithin, fill: ArrayFill, filter: ArrayFilter, find: ArrayFind, indexOf: ArrayIndexOf, join: ArrayJoin, map: ArrayMap, pop: ArrayPop, push: ArrayPush$1, reduce: ArrayReduce, reverse: ArrayReverse, shift: ArrayShift, slice: ArraySlice, some: ArraySome, sort: ArraySort, splice: ArraySplice, unshift: ArrayUnshift, forEach, } = Array.prototype;\nconst { fromCharCode: StringFromCharCode } = String;\nconst { charCodeAt: StringCharCodeAt, replace: StringReplace, split: StringSplit, slice: StringSlice, toLowerCase: StringToLowerCase, } = String.prototype;\nfunction isUndefined$1(obj) {\n    return obj === undefined;\n}\nfunction isNull(obj) {\n    return obj === null;\n}\nfunction isTrue(obj) {\n    return obj === true;\n}\nfunction isFalse(obj) {\n    return obj === false;\n}\nfunction isBoolean(obj) {\n    return typeof obj === 'boolean';\n}\nfunction isFunction$1(obj) {\n    return typeof obj === 'function';\n}\nfunction isObject(obj) {\n    return typeof obj === 'object';\n}\nfunction isString(obj) {\n    return typeof obj === 'string';\n}\nfunction isNumber(obj) {\n    return typeof obj === 'number';\n}\nfunction noop() {\n    /* Do nothing */\n}\nconst OtS$1 = {}.toString;\nfunction toString$1(obj) {\n    if (obj && obj.toString) {\n        // Arrays might hold objects with \"null\" prototype So using\n        // Array.prototype.toString directly will cause an error Iterate through\n        // all the items and handle individually.\n        if (isArray$1(obj)) {\n            return ArrayJoin.call(ArrayMap.call(obj, toString$1), ',');\n        }\n        return obj.toString();\n    }\n    else if (typeof obj === 'object') {\n        return OtS$1.call(obj);\n    }\n    else {\n        return obj + '';\n    }\n}\nfunction getPropertyDescriptor(o, p) {\n    do {\n        const d = getOwnPropertyDescriptor$1(o, p);\n        if (!isUndefined$1(d)) {\n            return d;\n        }\n        o = getPrototypeOf$1(o);\n    } while (o !== null);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and\n * ariaGrabbed) are deprecated:\n * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes\n *\n * The above list of 46 aria attributes is consistent with the following resources:\n * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060\n * https://wicg.github.io/aom/spec/aria-reflection.html\n *\n * NOTE: If you update this list, please update test files that implicitly reference this list!\n * Searching the codebase for `aria-flowto` and `ariaFlowTo` should be good enough to find all usages.\n */\nconst AriaPropertyNames = [\n    'ariaActiveDescendant',\n    'ariaAtomic',\n    'ariaAutoComplete',\n    'ariaBusy',\n    'ariaChecked',\n    'ariaColCount',\n    'ariaColIndex',\n    'ariaColSpan',\n    'ariaControls',\n    'ariaCurrent',\n    'ariaDescribedBy',\n    'ariaDetails',\n    'ariaDisabled',\n    'ariaErrorMessage',\n    'ariaExpanded',\n    'ariaFlowTo',\n    'ariaHasPopup',\n    'ariaHidden',\n    'ariaInvalid',\n    'ariaKeyShortcuts',\n    'ariaLabel',\n    'ariaLabelledBy',\n    'ariaLevel',\n    'ariaLive',\n    'ariaModal',\n    'ariaMultiLine',\n    'ariaMultiSelectable',\n    'ariaOrientation',\n    'ariaOwns',\n    'ariaPlaceholder',\n    'ariaPosInSet',\n    'ariaPressed',\n    'ariaReadOnly',\n    'ariaRelevant',\n    'ariaRequired',\n    'ariaRoleDescription',\n    'ariaRowCount',\n    'ariaRowIndex',\n    'ariaRowSpan',\n    'ariaSelected',\n    'ariaSetSize',\n    'ariaSort',\n    'ariaValueMax',\n    'ariaValueMin',\n    'ariaValueNow',\n    'ariaValueText',\n    'role',\n];\nconst { AriaAttrNameToPropNameMap, AriaPropNameToAttrNameMap } = /*@__PURE__*/ (() => {\n    const AriaAttrNameToPropNameMap = create(null);\n    const AriaPropNameToAttrNameMap = create(null);\n    // Synthetic creation of all AOM property descriptors for Custom Elements\n    forEach.call(AriaPropertyNames, (propName) => {\n        const attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, () => 'aria-'));\n        AriaAttrNameToPropNameMap[attrName] = propName;\n        AriaPropNameToAttrNameMap[propName] = attrName;\n    });\n    return { AriaAttrNameToPropNameMap, AriaPropNameToAttrNameMap };\n})();\n// These attributes take either an ID or a list of IDs as values.\n// This includes aria-* attributes as well as the special non-ARIA \"for\" attribute\nconst ID_REFERENCING_ATTRIBUTES_SET = new Set([\n    'aria-activedescendant',\n    'aria-controls',\n    'aria-describedby',\n    'aria-details',\n    'aria-errormessage',\n    'aria-flowto',\n    'aria-labelledby',\n    'aria-owns',\n    'for',\n]);\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// See browser support for globalThis:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility\n/* istanbul ignore next */\n// @ts-ignore\nconst _globalThis = typeof globalThis === 'object' ? globalThis : window;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst KEY__IS_NATIVE_SHADOW_ROOT_DEFINED = '$isNativeShadowRootDefined$';\nconst KEY__SHADOW_RESOLVER = '$shadowResolver$';\nconst KEY__SHADOW_STATIC = '$shadowStaticNode$';\nconst KEY__SHADOW_TOKEN = '$shadowToken$';\nconst KEY__SYNTHETIC_MODE = '$$lwc-synthetic-mode';\nconst KEY__SCOPED_CSS = '$scoped$';\nconst KEY__NATIVE_GET_ELEMENT_BY_ID = '$nativeGetElementById$';\nconst KEY__NATIVE_QUERY_SELECTOR_ALL = '$nativeQuerySelectorAll$';\nconst XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\nconst SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nconst XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CAMEL_REGEX = /-([a-z])/g;\n// Convoluted map generation so that @lwc/shared remains fully tree-shakable (verify-treeshakable)\nconst { NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING, NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING } = \n/*#__PURE__*/ (() => {\n    /**\n     * Map composed of properties to attributes not following the HTML property to attribute mapping\n     * convention.\n     */\n    const NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING = new Map([\n        ['accessKey', 'accesskey'],\n        ['readOnly', 'readonly'],\n        ['tabIndex', 'tabindex'],\n        ['bgColor', 'bgcolor'],\n        ['colSpan', 'colspan'],\n        ['rowSpan', 'rowspan'],\n        ['contentEditable', 'contenteditable'],\n        ['crossOrigin', 'crossorigin'],\n        ['dateTime', 'datetime'],\n        ['formAction', 'formaction'],\n        ['isMap', 'ismap'],\n        ['maxLength', 'maxlength'],\n        ['minLength', 'minlength'],\n        ['noValidate', 'novalidate'],\n        ['useMap', 'usemap'],\n        ['htmlFor', 'for'],\n    ]);\n    /**\n     * Inverted map with attribute name key and property name value.\n     */\n    const NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING = new Map();\n    NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING.forEach((value, key) => NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING.set(value, key));\n    return {\n        NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING,\n        NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING,\n    };\n})();\n/**\n * Map associating previously transformed HTML property into HTML attribute.\n */\nconst CACHED_PROPERTY_ATTRIBUTE_MAPPING = new Map();\n/**\n * Map associating previously transformed HTML attribute into HTML property.\n */\nconst CACHED_ATTRIBUTE_PROPERTY_MAPPING = new Map();\nfunction htmlPropertyToAttribute(propName) {\n    const ariaAttributeName = AriaPropNameToAttrNameMap[propName];\n    if (!isUndefined$1(ariaAttributeName)) {\n        return ariaAttributeName;\n    }\n    const specialAttributeName = NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING.get(propName);\n    if (!isUndefined$1(specialAttributeName)) {\n        return specialAttributeName;\n    }\n    const cachedAttributeName = CACHED_PROPERTY_ATTRIBUTE_MAPPING.get(propName);\n    if (!isUndefined$1(cachedAttributeName)) {\n        return cachedAttributeName;\n    }\n    let attributeName = '';\n    for (let i = 0, len = propName.length; i < len; i++) {\n        const code = StringCharCodeAt.call(propName, i);\n        if (code >= 65 && // \"A\"\n            code <= 90 // \"Z\"\n        ) {\n            attributeName += '-' + StringFromCharCode(code + 32);\n        }\n        else {\n            attributeName += StringFromCharCode(code);\n        }\n    }\n    CACHED_PROPERTY_ATTRIBUTE_MAPPING.set(propName, attributeName);\n    return attributeName;\n}\nfunction htmlAttributeToProperty(attrName) {\n    const ariaPropertyName = AriaAttrNameToPropNameMap[attrName];\n    if (!isUndefined$1(ariaPropertyName)) {\n        return ariaPropertyName;\n    }\n    const specialPropertyName = NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING.get(attrName);\n    if (!isUndefined$1(specialPropertyName)) {\n        return specialPropertyName;\n    }\n    const cachedPropertyName = CACHED_ATTRIBUTE_PROPERTY_MAPPING.get(attrName);\n    if (!isUndefined$1(cachedPropertyName)) {\n        return cachedPropertyName;\n    }\n    const propertyName = StringReplace.call(attrName, CAMEL_REGEX, (g) => g[1].toUpperCase());\n    CACHED_ATTRIBUTE_PROPERTY_MAPPING.set(attrName, propertyName);\n    return propertyName;\n}\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ESCAPED_CHARS = {\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n};\nfunction htmlEscape(str, attrMode = false) {\n    const searchValue = attrMode ? /[\"&]/g : /[\"'<>&]/g;\n    return str.replace(searchValue, (char) => ESCAPED_CHARS[char]);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Increment whenever the LWC template compiler changes\nconst LWC_VERSION = \"2.38.0\";\nconst LWC_VERSION_COMMENT_REGEX = /\\/\\*LWC compiler v([\\d.]+)\\*\\/\\s*}/;\n/** version: 2.38.0 */\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst features = {\n    DUMMY_TEST_FLAG: null,\n    ENABLE_FORCE_NATIVE_SHADOW_MODE_FOR_TEST: null,\n    ENABLE_MIXED_SHADOW_MODE: null,\n    ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE: null,\n    ENABLE_WIRE_SYNC_EMIT: null,\n    ENABLE_LIGHT_GET_ROOT_NODE_PATCH: null,\n    DISABLE_LIGHT_DOM_UNSCOPED_CSS: null,\n    ENABLE_FROZEN_TEMPLATE: null,\n    DISABLE_ARIA_REFLECTION_POLYFILL: null,\n};\n// eslint-disable-next-line no-restricted-properties\nif (!_globalThis.lwcRuntimeFlags) {\n    Object.defineProperty(_globalThis, 'lwcRuntimeFlags', { value: create(null) });\n}\n// eslint-disable-next-line no-restricted-properties\nconst flags = _globalThis.lwcRuntimeFlags;\n/**\n * Set the value at runtime of a given feature flag. This method only be invoked once per feature\n * flag. It is meant to be used during the app initialization.\n */\nfunction setFeatureFlag(name, value) {\n    if (!isBoolean(value)) {\n        const message = `Failed to set the value \"${value}\" for the runtime feature flag \"${name}\". Runtime feature flags can only be set to a boolean value.`;\n        if (true) {\n            throw new TypeError(message);\n        }\n        else {}\n    }\n    if (isUndefined$1(features[name])) {\n        const availableFlags = keys(features)\n            .map((name) => `\"${name}\"`)\n            .join(', ');\n        // eslint-disable-next-line no-console\n        console.warn(`Failed to set the value \"${value}\" for the runtime feature flag \"${name}\" because it is undefined. Available flags: ${availableFlags}.`);\n        return;\n    }\n    // This may seem redundant, but `process.env.NODE_ENV === 'test-karma-lwc'` is replaced by Karma tests\n    if (true) {\n        // Allow the same flag to be set more than once outside of production to enable testing\n        flags[name] = value;\n    }\n    else {}\n}\n/**\n * Set the value at runtime of a given feature flag. This method should only be used for testing\n * purposes. It is a no-op when invoked in production mode.\n */\nfunction setFeatureFlagForTest(name, value) {\n    // This may seem redundant, but `process.env.NODE_ENV === 'test-karma-lwc'` is replaced by Karma tests\n    if (true) {\n        setFeatureFlag(name, value);\n    }\n}\n/** version: 2.38.0 */\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect(propName, prototype) {\n    return isUndefined$1(getOwnPropertyDescriptor$1(prototype, propName));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction createAriaPropertyPropertyDescriptor(attrName) {\n    // Note that we need to call this.{get,set,has,remove}Attribute rather than dereferencing\n    // from Element.prototype, because these methods are overridden in LightningElement.\n    return {\n        get() {\n            // reflect what's in the attribute\n            return this.hasAttribute(attrName) ? this.getAttribute(attrName) : null;\n        },\n        set(newValue) {\n            // reflect into the corresponding attribute\n            if (isNull(newValue)) {\n                this.removeAttribute(attrName);\n            }\n            else {\n                this.setAttribute(attrName, newValue);\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    };\n}\nfunction patch$1(propName, prototype) {\n    const attrName = AriaPropNameToAttrNameMap[propName];\n    const descriptor = createAriaPropertyPropertyDescriptor(attrName);\n    defineProperty(prototype, propName, descriptor);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction applyAriaReflection(prototype = Element.prototype) {\n    const ElementPrototypeAriaPropertyNames = keys(AriaPropNameToAttrNameMap);\n    for (let i = 0, len = ElementPrototypeAriaPropertyNames.length; i < len; i += 1) {\n        const propName = ElementPrototypeAriaPropertyNames[i];\n        if (detect(propName, prototype)) {\n            patch$1(propName, prototype);\n        }\n    }\n}\n/** version: 2.38.0 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (!lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {\n    // If DISABLE_ARIA_REFLECTION_POLYFILL is false, then we need to apply the ARIA reflection polyfill globally,\n    // i.e. to the global Element.prototype\n    applyAriaReflection();\n}\n\n/* proxy-compat-disable */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst onReportingEnabledCallbacks = [];\n/** The currently assigned reporting dispatcher. */\nlet currentDispatcher$1 = noop;\n/**\n * Whether reporting is enabled.\n *\n * Note that this may seem redundant, given you can just check if the currentDispatcher is undefined,\n * but it turns out that Terser only strips out unused code if we use this explicit boolean.\n */\nlet enabled$1 = false;\nconst reportingControl = {\n    /**\n     * Attach a new reporting control (aka dispatcher).\n     *\n     * @param dispatcher - reporting control\n     */\n    attachDispatcher(dispatcher) {\n        enabled$1 = true;\n        currentDispatcher$1 = dispatcher;\n        for (const callback of onReportingEnabledCallbacks) {\n            try {\n                callback();\n            }\n            catch (err) {\n                // This should never happen. But if it does, we don't want one callback to cause another to fail\n                // eslint-disable-next-line no-console\n                console.error('Could not invoke callback', err);\n            }\n        }\n        onReportingEnabledCallbacks.length = 0; // clear the array\n    },\n    /**\n     * Detach the current reporting control (aka dispatcher).\n     */\n    detachDispatcher() {\n        enabled$1 = false;\n        currentDispatcher$1 = noop;\n    },\n};\n/**\n * Call a callback when reporting is enabled, or immediately if reporting is already enabled.\n * Will only ever be called once.\n * @param callback\n */\nfunction onReportingEnabled(callback) {\n    if (enabled$1) {\n        // call immediately\n        callback();\n    }\n    else {\n        // call later\n        onReportingEnabledCallbacks.push(callback);\n    }\n}\n/**\n * Report to the current dispatcher, if there is one.\n * @param reportingEventId\n * @param payload - data to report\n */\nfunction report(reportingEventId, payload) {\n    if (enabled$1) {\n        currentDispatcher$1(reportingEventId, payload);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getComponentTag(vm) {\n    return `<${StringToLowerCase.call(vm.tagName)}>`;\n}\n// TODO [#1695]: Unify getComponentStack and getErrorComponentStack\nfunction getComponentStack(vm) {\n    const stack = [];\n    let prefix = '';\n    while (!isNull(vm.owner)) {\n        ArrayPush$1.call(stack, prefix + getComponentTag(vm));\n        vm = vm.owner;\n        prefix += '\\t';\n    }\n    return ArrayJoin.call(stack, '\\n');\n}\nfunction getErrorComponentStack(vm) {\n    const wcStack = [];\n    let currentVm = vm;\n    while (!isNull(currentVm)) {\n        ArrayPush$1.call(wcStack, getComponentTag(currentVm));\n        currentVm = currentVm.owner;\n    }\n    return wcStack.reverse().join('\\n\\t');\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction addErrorComponentStack(vm, error) {\n    if (!isFrozen(error) && isUndefined$1(error.wcStack)) {\n        const wcStack = getErrorComponentStack(vm);\n        defineProperty(error, 'wcStack', {\n            get() {\n                return wcStack;\n            },\n        });\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst alreadyLoggedMessages = new Set();\n// Only used in LWC's Karma tests\nif (false) {}\nfunction log(method, message, vm, once) {\n    let msg = `[LWC ${method}]: ${message}`;\n    if (!isUndefined$1(vm)) {\n        msg = `${msg}\\n${getComponentStack(vm)}`;\n    }\n    if (once) {\n        if (alreadyLoggedMessages.has(msg)) {\n            return;\n        }\n        alreadyLoggedMessages.add(msg);\n    }\n    // In Jest tests, reduce the warning and error verbosity by not printing the callstack\n    if (false) {}\n    try {\n        throw new Error(msg);\n    }\n    catch (e) {\n        /* eslint-disable-next-line no-console */\n        console[method](e);\n    }\n}\nfunction logError(message, vm) {\n    log('error', message, vm, false);\n}\nfunction logWarn(message, vm) {\n    log('warn', message, vm, false);\n}\nfunction logWarnOnce(message, vm) {\n    log('warn', message, vm, true);\n}\n\n/*\n * Copyright (c) 2019, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst TargetToReactiveRecordMap = new WeakMap();\nfunction getReactiveRecord(target) {\n    let reactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (isUndefined$1(reactiveRecord)) {\n        const newRecord = create(null);\n        reactiveRecord = newRecord;\n        TargetToReactiveRecordMap.set(target, newRecord);\n    }\n    return reactiveRecord;\n}\nlet currentReactiveObserver = null;\nfunction valueMutated(target, key) {\n    const reactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (!isUndefined$1(reactiveRecord)) {\n        const reactiveObservers = reactiveRecord[key];\n        if (!isUndefined$1(reactiveObservers)) {\n            for (let i = 0, len = reactiveObservers.length; i < len; i += 1) {\n                const ro = reactiveObservers[i];\n                ro.notify();\n            }\n        }\n    }\n}\nfunction valueObserved(target, key) {\n    // We should determine if an active Observing Record is present to track mutations.\n    if (currentReactiveObserver === null) {\n        return;\n    }\n    const ro = currentReactiveObserver;\n    const reactiveRecord = getReactiveRecord(target);\n    let reactiveObservers = reactiveRecord[key];\n    if (isUndefined$1(reactiveObservers)) {\n        reactiveObservers = [];\n        reactiveRecord[key] = reactiveObservers;\n    }\n    else if (reactiveObservers[0] === ro) {\n        return; // perf optimization considering that most subscriptions will come from the same record\n    }\n    if (ArrayIndexOf.call(reactiveObservers, ro) === -1) {\n        ro.link(reactiveObservers);\n    }\n}\nclass ReactiveObserver {\n    constructor(callback) {\n        this.listeners = [];\n        this.callback = callback;\n    }\n    observe(job) {\n        const inceptionReactiveRecord = currentReactiveObserver;\n        currentReactiveObserver = this;\n        let error;\n        try {\n            job();\n        }\n        catch (e) {\n            error = Object(e);\n        }\n        finally {\n            currentReactiveObserver = inceptionReactiveRecord;\n            if (error !== undefined) {\n                throw error; // eslint-disable-line no-unsafe-finally\n            }\n        }\n    }\n    /**\n     * This method is responsible for disconnecting the Reactive Observer\n     * from any Reactive Record that has a reference to it, to prevent future\n     * notifications about previously recorded access.\n     */\n    reset() {\n        const { listeners } = this;\n        const len = listeners.length;\n        if (len > 0) {\n            for (let i = 0; i < len; i += 1) {\n                const set = listeners[i];\n                const pos = ArrayIndexOf.call(listeners[i], this);\n                ArraySplice.call(set, pos, 1);\n            }\n            listeners.length = 0;\n        }\n    }\n    // friend methods\n    notify() {\n        this.callback.call(undefined, this);\n    }\n    link(reactiveObservers) {\n        ArrayPush$1.call(reactiveObservers, this);\n        // we keep track of observing records where the observing record was added to so we can do some clean up later on\n        ArrayPush$1.call(this.listeners, reactiveObservers);\n    }\n}\nfunction componentValueMutated(vm, key) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    {\n        valueMutated(vm.component, key);\n    }\n}\nfunction componentValueObserved(vm, key) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    {\n        valueObserved(vm.component, key);\n    }\n}\nfunction createReactiveObserver(callback) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    return new ReactiveObserver(callback) ;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet nextTickCallbackQueue = [];\nconst SPACE_CHAR = 32;\nconst EmptyObject = seal(create(null));\nconst EmptyArray = seal([]);\nfunction flushCallbackQueue() {\n    if (true) {\n        if (nextTickCallbackQueue.length === 0) {\n            throw new Error(`Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.`);\n        }\n    }\n    const callbacks = nextTickCallbackQueue;\n    nextTickCallbackQueue = []; // reset to a new queue\n    for (let i = 0, len = callbacks.length; i < len; i += 1) {\n        callbacks[i]();\n    }\n}\nfunction addCallbackToNextTick(callback) {\n    if (true) {\n        if (!isFunction$1(callback)) {\n            throw new Error(`Internal Error: addCallbackToNextTick() can only accept a function callback`);\n        }\n    }\n    if (nextTickCallbackQueue.length === 0) {\n        Promise.resolve().then(flushCallbackQueue);\n    }\n    ArrayPush$1.call(nextTickCallbackQueue, callback);\n}\nfunction guid() {\n    function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000)\n            .toString(16)\n            .substring(1);\n    }\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n// Borrowed from Vue template compiler.\n// https://github.com/vuejs/vue/blob/531371b818b0e31a989a06df43789728f23dc4e8/src/platforms/web/util/style.js#L5-L16\nconst DECLARATION_DELIMITER = /;(?![^(]*\\))/g;\nconst PROPERTY_DELIMITER = /:(.+)/;\nfunction parseStyleText(cssText) {\n    const styleMap = {};\n    const declarations = cssText.split(DECLARATION_DELIMITER);\n    for (const declaration of declarations) {\n        if (declaration) {\n            const [prop, value] = declaration.split(PROPERTY_DELIMITER);\n            if (prop !== undefined && value !== undefined) {\n                styleMap[prop.trim()] = value.trim();\n            }\n        }\n    }\n    return styleMap;\n}\n// Make a shallow copy of an object but omit the given key\nfunction cloneAndOmitKey(object, keyToOmit) {\n    const result = {};\n    for (const key of keys(object)) {\n        if (key !== keyToOmit) {\n            result[key] = object[key];\n        }\n    }\n    return result;\n}\nfunction flattenStylesheets(stylesheets) {\n    const list = [];\n    for (const stylesheet of stylesheets) {\n        if (!isArray$1(stylesheet)) {\n            list.push(stylesheet);\n        }\n        else {\n            list.push(...flattenStylesheets(stylesheet));\n        }\n    }\n    return list;\n}\n// Set a ref (lwc:ref) on a VM, from a template API\nfunction setRefVNode(vm, ref, vnode) {\n    if ( true && isUndefined$1(vm.refVNodes)) {\n        throw new Error('refVNodes must be defined when setting a ref');\n    }\n    // If this method is called, then vm.refVNodes is set as the template has refs.\n    // If not, then something went wrong and we threw an error above.\n    const refVNodes = vm.refVNodes;\n    // In cases of conflict (two elements with the same ref), prefer, the last one,\n    // in depth-first traversal order.\n    if (!(ref in refVNodes) || refVNodes[ref].key < vnode.key) {\n        refVNodes[ref] = vnode;\n    }\n}\n// Throw an error if we're running in prod mode. Ensures code is truly removed from prod mode.\nfunction assertNotProd() {\n    /* istanbul ignore if */\n    if (false) {}\n}\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction resolveCircularModuleDependency(fn) {\n    const module = fn();\n    return (module === null || module === void 0 ? void 0 : module.__esModule) ? module.default : module;\n}\nfunction isCircularModuleDependency(obj) {\n    return isFunction$1(obj) && hasOwnProperty$1.call(obj, '__circular__');\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// This is a temporary workaround to get the @lwc/engine-server to evaluate in node without having\n// to inject at runtime.\nconst HTMLElementConstructor = typeof HTMLElement !== 'undefined' ? HTMLElement : function () { };\nconst HTMLElementPrototype = HTMLElementConstructor.prototype;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// These properties get added to LWCElement.prototype publicProps automatically\nconst defaultDefHTMLPropertyNames = [\n    'accessKey',\n    'dir',\n    'draggable',\n    'hidden',\n    'id',\n    'lang',\n    'spellcheck',\n    'tabIndex',\n    'title',\n];\nfunction offsetPropertyErrorMessage(name) {\n    return `Using the \\`${name}\\` property is an anti-pattern because it rounds the value to an integer. Instead, use the \\`getBoundingClientRect\\` method to obtain fractional values for the size of an element and its position relative to the viewport.`;\n}\n// Global HTML Attributes & Properties\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\n//\n// If you update this list, check for test files that recapitulate the same list. Searching the codebase\n// for e.g. \"dropzone\" should suffice.\nconst globalHTMLProperties = {\n    accessKey: {\n        attribute: 'accesskey',\n    },\n    accessKeyLabel: {\n        readOnly: true,\n    },\n    className: {\n        attribute: 'class',\n        error: 'Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead.',\n    },\n    contentEditable: {\n        attribute: 'contenteditable',\n    },\n    dataset: {\n        readOnly: true,\n        error: \"Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead.\",\n    },\n    dir: {\n        attribute: 'dir',\n    },\n    draggable: {\n        attribute: 'draggable',\n    },\n    dropzone: {\n        attribute: 'dropzone',\n        readOnly: true,\n    },\n    hidden: {\n        attribute: 'hidden',\n    },\n    id: {\n        attribute: 'id',\n    },\n    inputMode: {\n        attribute: 'inputmode',\n    },\n    lang: {\n        attribute: 'lang',\n    },\n    slot: {\n        attribute: 'slot',\n        error: 'Using the `slot` property is an anti-pattern.',\n    },\n    spellcheck: {\n        attribute: 'spellcheck',\n    },\n    style: {\n        attribute: 'style',\n    },\n    tabIndex: {\n        attribute: 'tabindex',\n    },\n    title: {\n        attribute: 'title',\n    },\n    translate: {\n        attribute: 'translate',\n    },\n    // additional \"global attributes\" that are not present in the link above.\n    isContentEditable: {\n        readOnly: true,\n    },\n    offsetHeight: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetHeight'),\n    },\n    offsetLeft: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetLeft'),\n    },\n    offsetParent: {\n        readOnly: true,\n    },\n    offsetTop: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetTop'),\n    },\n    offsetWidth: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetWidth'),\n    },\n    role: {\n        attribute: 'role',\n    },\n};\nlet controlledElement = null;\nlet controlledAttributeName;\nfunction isAttributeLocked(elm, attrName) {\n    return elm !== controlledElement || attrName !== controlledAttributeName;\n}\nfunction lockAttribute(_elm, _key) {\n    controlledElement = null;\n    controlledAttributeName = undefined;\n}\nfunction unlockAttribute(elm, key) {\n    controlledElement = elm;\n    controlledAttributeName = key;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This is a descriptor map that contains\n * all standard properties that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base HTML Element and\n * Base Lightning Element should support.\n */\nconst HTMLElementOriginalDescriptors = create(null);\nforEach.call(keys(AriaPropNameToAttrNameMap), (propName) => {\n    // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n    // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.\n    const descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);\n    if (!isUndefined$1(descriptor)) {\n        HTMLElementOriginalDescriptors[propName] = descriptor;\n    }\n});\nforEach.call(defaultDefHTMLPropertyNames, (propName) => {\n    // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n    // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into\n    // this category, so, better to be sure.\n    const descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);\n    if (!isUndefined$1(descriptor)) {\n        HTMLElementOriginalDescriptors[propName] = descriptor;\n    }\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction generateDataDescriptor(options) {\n    return assign({\n        configurable: true,\n        enumerable: true,\n        writable: true,\n    }, options);\n}\nfunction generateAccessorDescriptor(options) {\n    return assign({\n        configurable: true,\n        enumerable: true,\n    }, options);\n}\nlet isDomMutationAllowed = false;\nfunction unlockDomMutation() {\n    assertNotProd(); // this method should never leak to prod\n    isDomMutationAllowed = true;\n}\nfunction lockDomMutation() {\n    assertNotProd(); // this method should never leak to prod\n    isDomMutationAllowed = false;\n}\nfunction logMissingPortalError(name, type) {\n    return logError(`The \\`${name}\\` ${type} is available only on elements that use the \\`lwc:dom=\"manual\"\\` directive.`);\n}\nfunction patchElementWithRestrictions(elm, options) {\n    assertNotProd(); // this method should never leak to prod\n    const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n    const descriptors = {\n        outerHTML: generateAccessorDescriptor({\n            get() {\n                return originalOuterHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set outerHTML on Element.`);\n            },\n        }),\n    };\n    // Apply extra restriction related to DOM manipulation if the element is not a portal.\n    if (!options.isLight && options.isSynthetic && !options.isPortal) {\n        const { appendChild, insertBefore, removeChild, replaceChild } = elm;\n        const originalNodeValueDescriptor = getPropertyDescriptor(elm, 'nodeValue');\n        const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n        const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');\n        assign(descriptors, {\n            appendChild: generateDataDescriptor({\n                value(aChild) {\n                    logMissingPortalError('appendChild', 'method');\n                    return appendChild.call(this, aChild);\n                },\n            }),\n            insertBefore: generateDataDescriptor({\n                value(newNode, referenceNode) {\n                    if (!isDomMutationAllowed) {\n                        logMissingPortalError('insertBefore', 'method');\n                    }\n                    return insertBefore.call(this, newNode, referenceNode);\n                },\n            }),\n            removeChild: generateDataDescriptor({\n                value(aChild) {\n                    if (!isDomMutationAllowed) {\n                        logMissingPortalError('removeChild', 'method');\n                    }\n                    return removeChild.call(this, aChild);\n                },\n            }),\n            replaceChild: generateDataDescriptor({\n                value(newChild, oldChild) {\n                    logMissingPortalError('replaceChild', 'method');\n                    return replaceChild.call(this, newChild, oldChild);\n                },\n            }),\n            nodeValue: generateAccessorDescriptor({\n                get() {\n                    return originalNodeValueDescriptor.get.call(this);\n                },\n                set(value) {\n                    if (!isDomMutationAllowed) {\n                        logMissingPortalError('nodeValue', 'property');\n                    }\n                    originalNodeValueDescriptor.set.call(this, value);\n                },\n            }),\n            textContent: generateAccessorDescriptor({\n                get() {\n                    return originalTextContentDescriptor.get.call(this);\n                },\n                set(value) {\n                    logMissingPortalError('textContent', 'property');\n                    originalTextContentDescriptor.set.call(this, value);\n                },\n            }),\n            innerHTML: generateAccessorDescriptor({\n                get() {\n                    return originalInnerHTMLDescriptor.get.call(this);\n                },\n                set(value) {\n                    logMissingPortalError('innerHTML', 'property');\n                    return originalInnerHTMLDescriptor.set.call(this, value);\n                },\n            }),\n        });\n    }\n    defineProperties(elm, descriptors);\n}\nfunction getShadowRootRestrictionsDescriptors(sr) {\n    assertNotProd(); // this method should never leak to prod\n    // Disallowing properties in dev mode only to avoid people doing the wrong\n    // thing when using the real shadow root, because if that's the case,\n    // the component will not work when running with synthetic shadow.\n    const originalAddEventListener = sr.addEventListener;\n    const originalInnerHTMLDescriptor = getPropertyDescriptor(sr, 'innerHTML');\n    const originalTextContentDescriptor = getPropertyDescriptor(sr, 'textContent');\n    return {\n        innerHTML: generateAccessorDescriptor({\n            get() {\n                return originalInnerHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set innerHTML on ShadowRoot.`);\n            },\n        }),\n        textContent: generateAccessorDescriptor({\n            get() {\n                return originalTextContentDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set textContent on ShadowRoot.`);\n            },\n        }),\n        addEventListener: generateDataDescriptor({\n            value(type, listener, options) {\n                // TODO [#420]: this is triggered when the component author attempts to add a listener\n                // programmatically into its Component's shadow root\n                if (!isUndefined$1(options)) {\n                    logError('The `addEventListener` method on ShadowRoot does not support any options.', getAssociatedVMIfPresent(this));\n                }\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                return originalAddEventListener.apply(this, arguments);\n            },\n        }),\n    };\n}\n// Custom Elements Restrictions:\n// -----------------------------\nfunction getCustomElementRestrictionsDescriptors(elm) {\n    assertNotProd(); // this method should never leak to prod\n    const originalAddEventListener = elm.addEventListener;\n    const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n    const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n    const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');\n    return {\n        innerHTML: generateAccessorDescriptor({\n            get() {\n                return originalInnerHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set innerHTML on HTMLElement.`);\n            },\n        }),\n        outerHTML: generateAccessorDescriptor({\n            get() {\n                return originalOuterHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set outerHTML on HTMLElement.`);\n            },\n        }),\n        textContent: generateAccessorDescriptor({\n            get() {\n                return originalTextContentDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set textContent on HTMLElement.`);\n            },\n        }),\n        addEventListener: generateDataDescriptor({\n            value(type, listener, options) {\n                // TODO [#420]: this is triggered when the component author attempts to add a listener\n                // programmatically into a lighting element node\n                if (!isUndefined$1(options)) {\n                    logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));\n                }\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                return originalAddEventListener.apply(this, arguments);\n            },\n        }),\n    };\n}\nfunction getComponentRestrictionsDescriptors() {\n    assertNotProd(); // this method should never leak to prod\n    return {\n        tagName: generateAccessorDescriptor({\n            get() {\n                throw new Error(`Usage of property \\`tagName\\` is disallowed because the component itself does` +\n                    ` not know which tagName will be used to create the element, therefore writing` +\n                    ` code that check for that value is error prone.`);\n            },\n            configurable: true,\n            enumerable: false, // no enumerable properties on component\n        }),\n    };\n}\nfunction getLightningElementPrototypeRestrictionsDescriptors(proto) {\n    assertNotProd(); // this method should never leak to prod\n    const originalDispatchEvent = proto.dispatchEvent;\n    const descriptors = {\n        dispatchEvent: generateDataDescriptor({\n            value(event) {\n                const vm = getAssociatedVM(this);\n                if (!isNull(event) && isObject(event)) {\n                    const { type } = event;\n                    if (!/^[a-z][a-z0-9_]*$/.test(type)) {\n                        logError(`Invalid event type \"${type}\" dispatched in element ${getComponentTag(vm)}.` +\n                            ` Event name must start with a lowercase letter and followed only lowercase` +\n                            ` letters, numbers, and underscores`, vm);\n                    }\n                }\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                return originalDispatchEvent.apply(this, arguments);\n            },\n        }),\n    };\n    forEach.call(getOwnPropertyNames$1(globalHTMLProperties), (propName) => {\n        if (propName in proto) {\n            return; // no need to redefine something that we are already exposing\n        }\n        descriptors[propName] = generateAccessorDescriptor({\n            get() {\n                const { error, attribute } = globalHTMLProperties[propName];\n                const msg = [];\n                msg.push(`Accessing the global HTML property \"${propName}\" is disabled.`);\n                if (error) {\n                    msg.push(error);\n                }\n                else if (attribute) {\n                    msg.push(`Instead access it via \\`this.getAttribute(\"${attribute}\")\\`.`);\n                }\n                logError(msg.join('\\n'), getAssociatedVM(this));\n            },\n            set() {\n                const { readOnly } = globalHTMLProperties[propName];\n                if (readOnly) {\n                    logError(`The global HTML property \\`${propName}\\` is read-only.`, getAssociatedVM(this));\n                }\n            },\n        });\n    });\n    return descriptors;\n}\n// This routine will prevent access to certain properties on a shadow root instance to guarantee\n// that all components will work fine in IE11 and other browsers without shadow dom support.\nfunction patchShadowRootWithRestrictions(sr) {\n    defineProperties(sr, getShadowRootRestrictionsDescriptors(sr));\n}\nfunction patchCustomElementWithRestrictions(elm) {\n    const restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm);\n    const elmProto = getPrototypeOf$1(elm);\n    setPrototypeOf(elm, create(elmProto, restrictionsDescriptors));\n}\nfunction patchComponentWithRestrictions(cmp) {\n    defineProperties(cmp, getComponentRestrictionsDescriptors());\n}\nfunction patchLightningElementPrototypeWithRestrictions(proto) {\n    defineProperties(proto, getLightningElementPrototypeRestrictionsDescriptors(proto));\n}\n\nfunction updateComponentValue(vm, key, newValue) {\n    const { cmpFields } = vm;\n    if (newValue !== cmpFields[key]) {\n        cmpFields[key] = newValue;\n        componentValueMutated(vm, key);\n    }\n}\n\n/**\n * Copyright (C) 2017 salesforce.com, inc.\n */\nconst { isArray } = Array;\nconst { prototype: ObjectDotPrototype, getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, hasOwnProperty, } = Object;\nconst { push: ArrayPush, concat: ArrayConcat } = Array.prototype;\nconst OtS = {}.toString;\nfunction toString(obj) {\n    if (obj && obj.toString) {\n        return obj.toString();\n    }\n    else if (typeof obj === 'object') {\n        return OtS.call(obj);\n    }\n    else {\n        return obj + '';\n    }\n}\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\nconst proxyToValueMap = new WeakMap();\nfunction registerProxy(proxy, value) {\n    proxyToValueMap.set(proxy, value);\n}\nconst unwrap$1 = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;\n\nclass BaseProxyHandler {\n    constructor(membrane, value) {\n        this.originalTarget = value;\n        this.membrane = membrane;\n    }\n    // Shared utility methods\n    wrapDescriptor(descriptor) {\n        if (hasOwnProperty.call(descriptor, 'value')) {\n            descriptor.value = this.wrapValue(descriptor.value);\n        }\n        else {\n            const { set: originalSet, get: originalGet } = descriptor;\n            if (!isUndefined(originalGet)) {\n                descriptor.get = this.wrapGetter(originalGet);\n            }\n            if (!isUndefined(originalSet)) {\n                descriptor.set = this.wrapSetter(originalSet);\n            }\n        }\n        return descriptor;\n    }\n    copyDescriptorIntoShadowTarget(shadowTarget, key) {\n        const { originalTarget } = this;\n        // Note: a property might get defined multiple times in the shadowTarget\n        //       but it will always be compatible with the previous descriptor\n        //       to preserve the object invariants, which makes these lines safe.\n        const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);\n        // TODO: it should be impossible for the originalDescriptor to ever be undefined, this `if` can be removed\n        /* istanbul ignore else */\n        if (!isUndefined(originalDescriptor)) {\n            const wrappedDesc = this.wrapDescriptor(originalDescriptor);\n            ObjectDefineProperty(shadowTarget, key, wrappedDesc);\n        }\n    }\n    lockShadowTarget(shadowTarget) {\n        const { originalTarget } = this;\n        const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n        targetKeys.forEach((key) => {\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        });\n        const { membrane: { tagPropertyKey }, } = this;\n        if (!isUndefined(tagPropertyKey) && !hasOwnProperty.call(shadowTarget, tagPropertyKey)) {\n            ObjectDefineProperty(shadowTarget, tagPropertyKey, ObjectCreate(null));\n        }\n        preventExtensions(shadowTarget);\n    }\n    // Shared Traps\n    // TODO: apply() is never called\n    /* istanbul ignore next */\n    apply(shadowTarget, thisArg, argArray) {\n        /* No op */\n    }\n    // TODO: construct() is never called\n    /* istanbul ignore next */\n    construct(shadowTarget, argArray, newTarget) {\n        /* No op */\n    }\n    get(shadowTarget, key) {\n        const { originalTarget, membrane: { valueObserved }, } = this;\n        const value = originalTarget[key];\n        valueObserved(originalTarget, key);\n        return this.wrapValue(value);\n    }\n    has(shadowTarget, key) {\n        const { originalTarget, membrane: { tagPropertyKey, valueObserved }, } = this;\n        valueObserved(originalTarget, key);\n        // since key is never going to be undefined, and tagPropertyKey might be undefined\n        // we can simply compare them as the second part of the condition.\n        return key in originalTarget || key === tagPropertyKey;\n    }\n    ownKeys(shadowTarget) {\n        const { originalTarget, membrane: { tagPropertyKey }, } = this;\n        // if the membrane tag key exists and it is not in the original target, we add it to the keys.\n        const keys = isUndefined(tagPropertyKey) || hasOwnProperty.call(originalTarget, tagPropertyKey)\n            ? []\n            : [tagPropertyKey];\n        // small perf optimization using push instead of concat to avoid creating an extra array\n        ArrayPush.apply(keys, getOwnPropertyNames(originalTarget));\n        ArrayPush.apply(keys, getOwnPropertySymbols(originalTarget));\n        return keys;\n    }\n    isExtensible(shadowTarget) {\n        const { originalTarget } = this;\n        // optimization to avoid attempting to lock down the shadowTarget multiple times\n        if (!isExtensible(shadowTarget)) {\n            return false; // was already locked down\n        }\n        if (!isExtensible(originalTarget)) {\n            this.lockShadowTarget(shadowTarget);\n            return false;\n        }\n        return true;\n    }\n    getPrototypeOf(shadowTarget) {\n        const { originalTarget } = this;\n        return getPrototypeOf(originalTarget);\n    }\n    getOwnPropertyDescriptor(shadowTarget, key) {\n        const { originalTarget, membrane: { valueObserved, tagPropertyKey }, } = this;\n        // keys looked up via getOwnPropertyDescriptor need to be reactive\n        valueObserved(originalTarget, key);\n        let desc = getOwnPropertyDescriptor(originalTarget, key);\n        if (isUndefined(desc)) {\n            if (key !== tagPropertyKey) {\n                return undefined;\n            }\n            // if the key is the membrane tag key, and is not in the original target,\n            // we produce a synthetic descriptor and install it on the shadow target\n            desc = { value: undefined, writable: false, configurable: false, enumerable: false };\n            ObjectDefineProperty(shadowTarget, tagPropertyKey, desc);\n            return desc;\n        }\n        if (desc.configurable === false) {\n            // updating the descriptor to non-configurable on the shadow\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        }\n        // Note: by accessing the descriptor, the key is marked as observed\n        // but access to the value, setter or getter (if available) cannot observe\n        // mutations, just like regular methods, in which case we just do nothing.\n        return this.wrapDescriptor(desc);\n    }\n}\n\nconst getterMap$1 = new WeakMap();\nconst setterMap$1 = new WeakMap();\nconst reverseGetterMap = new WeakMap();\nconst reverseSetterMap = new WeakMap();\nclass ReactiveProxyHandler extends BaseProxyHandler {\n    wrapValue(value) {\n        return this.membrane.getProxy(value);\n    }\n    wrapGetter(originalGet) {\n        const wrappedGetter = getterMap$1.get(originalGet);\n        if (!isUndefined(wrappedGetter)) {\n            return wrappedGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the original getter with the original target\n            return handler.wrapValue(originalGet.call(unwrap$1(this)));\n        };\n        getterMap$1.set(originalGet, get);\n        reverseGetterMap.set(get, originalGet);\n        return get;\n    }\n    wrapSetter(originalSet) {\n        const wrappedSetter = setterMap$1.get(originalSet);\n        if (!isUndefined(wrappedSetter)) {\n            return wrappedSetter;\n        }\n        const set = function (v) {\n            // invoking the original setter with the original target\n            originalSet.call(unwrap$1(this), unwrap$1(v));\n        };\n        setterMap$1.set(originalSet, set);\n        reverseSetterMap.set(set, originalSet);\n        return set;\n    }\n    unwrapDescriptor(descriptor) {\n        if (hasOwnProperty.call(descriptor, 'value')) {\n            // dealing with a data descriptor\n            descriptor.value = unwrap$1(descriptor.value);\n        }\n        else {\n            const { set, get } = descriptor;\n            if (!isUndefined(get)) {\n                descriptor.get = this.unwrapGetter(get);\n            }\n            if (!isUndefined(set)) {\n                descriptor.set = this.unwrapSetter(set);\n            }\n        }\n        return descriptor;\n    }\n    unwrapGetter(redGet) {\n        const reverseGetter = reverseGetterMap.get(redGet);\n        if (!isUndefined(reverseGetter)) {\n            return reverseGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the red getter with the proxy of this\n            return unwrap$1(redGet.call(handler.wrapValue(this)));\n        };\n        getterMap$1.set(get, redGet);\n        reverseGetterMap.set(redGet, get);\n        return get;\n    }\n    unwrapSetter(redSet) {\n        const reverseSetter = reverseSetterMap.get(redSet);\n        if (!isUndefined(reverseSetter)) {\n            return reverseSetter;\n        }\n        const handler = this;\n        const set = function (v) {\n            // invoking the red setter with the proxy of this\n            redSet.call(handler.wrapValue(this), handler.wrapValue(v));\n        };\n        setterMap$1.set(set, redSet);\n        reverseSetterMap.set(redSet, set);\n        return set;\n    }\n    set(shadowTarget, key, value) {\n        const { originalTarget, membrane: { valueMutated }, } = this;\n        const oldValue = originalTarget[key];\n        if (oldValue !== value) {\n            originalTarget[key] = value;\n            valueMutated(originalTarget, key);\n        }\n        else if (key === 'length' && isArray(originalTarget)) {\n            // fix for issue #236: push will add the new index, and by the time length\n            // is updated, the internal length is already equal to the new length value\n            // therefore, the oldValue is equal to the value. This is the forking logic\n            // to support this use case.\n            valueMutated(originalTarget, key);\n        }\n        return true;\n    }\n    deleteProperty(shadowTarget, key) {\n        const { originalTarget, membrane: { valueMutated }, } = this;\n        delete originalTarget[key];\n        valueMutated(originalTarget, key);\n        return true;\n    }\n    setPrototypeOf(shadowTarget, prototype) {\n        /* istanbul ignore else */\n        if (true) {\n            throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${toString(this.originalTarget)}. Prototype of reactive objects cannot be changed.`);\n        }\n    }\n    preventExtensions(shadowTarget) {\n        if (isExtensible(shadowTarget)) {\n            const { originalTarget } = this;\n            preventExtensions(originalTarget);\n            // if the originalTarget is a proxy itself, it might reject\n            // the preventExtension call, in which case we should not attempt to lock down\n            // the shadow target.\n            // TODO: It should not actually be possible to reach this `if` statement.\n            // If a proxy rejects extensions, then calling preventExtensions will throw an error:\n            // https://codepen.io/nolanlawson-the-selector/pen/QWMOjbY\n            /* istanbul ignore if */\n            if (isExtensible(originalTarget)) {\n                return false;\n            }\n            this.lockShadowTarget(shadowTarget);\n        }\n        return true;\n    }\n    defineProperty(shadowTarget, key, descriptor) {\n        const { originalTarget, membrane: { valueMutated, tagPropertyKey }, } = this;\n        if (key === tagPropertyKey && !hasOwnProperty.call(originalTarget, key)) {\n            // To avoid leaking the membrane tag property into the original target, we must\n            // be sure that the original target doesn't have yet.\n            // NOTE: we do not return false here because Object.freeze and equivalent operations\n            // will attempt to set the descriptor to the same value, and expect no to throw. This\n            // is an small compromise for the sake of not having to diff the descriptors.\n            return true;\n        }\n        ObjectDefineProperty(originalTarget, key, this.unwrapDescriptor(descriptor));\n        // intentionally testing if false since it could be undefined as well\n        if (descriptor.configurable === false) {\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        }\n        valueMutated(originalTarget, key);\n        return true;\n    }\n}\n\nconst getterMap = new WeakMap();\nconst setterMap = new WeakMap();\nclass ReadOnlyHandler extends BaseProxyHandler {\n    wrapValue(value) {\n        return this.membrane.getReadOnlyProxy(value);\n    }\n    wrapGetter(originalGet) {\n        const wrappedGetter = getterMap.get(originalGet);\n        if (!isUndefined(wrappedGetter)) {\n            return wrappedGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the original getter with the original target\n            return handler.wrapValue(originalGet.call(unwrap$1(this)));\n        };\n        getterMap.set(originalGet, get);\n        return get;\n    }\n    wrapSetter(originalSet) {\n        const wrappedSetter = setterMap.get(originalSet);\n        if (!isUndefined(wrappedSetter)) {\n            return wrappedSetter;\n        }\n        const handler = this;\n        const set = function (v) {\n            /* istanbul ignore else */\n            if (true) {\n                const { originalTarget } = handler;\n                throw new Error(`Invalid mutation: Cannot invoke a setter on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n            }\n        };\n        setterMap.set(originalSet, set);\n        return set;\n    }\n    set(shadowTarget, key, value) {\n        /* istanbul ignore else */\n        if (true) {\n            const { originalTarget } = this;\n            const msg = isArray(originalTarget)\n                ? `Invalid mutation: Cannot mutate array at index ${key.toString()}. Array is read-only.`\n                : `Invalid mutation: Cannot set \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`;\n            throw new Error(msg);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n    deleteProperty(shadowTarget, key) {\n        /* istanbul ignore else */\n        if (true) {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot delete \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n    setPrototypeOf(shadowTarget, prototype) {\n        /* istanbul ignore else */\n        if (true) {\n            const { originalTarget } = this;\n            throw new Error(`Invalid prototype mutation: Cannot set prototype on \"${originalTarget}\". \"${originalTarget}\" prototype is read-only.`);\n        }\n    }\n    preventExtensions(shadowTarget) {\n        /* istanbul ignore else */\n        if (true) {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot preventExtensions on ${originalTarget}\". \"${originalTarget} is read-only.`);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n    defineProperty(shadowTarget, key, descriptor) {\n        /* istanbul ignore else */\n        if (true) {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot defineProperty \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n}\n\nfunction extract(objectOrArray) {\n    if (isArray(objectOrArray)) {\n        return objectOrArray.map((item) => {\n            const original = unwrap$1(item);\n            if (original !== item) {\n                return extract(original);\n            }\n            return item;\n        });\n    }\n    const obj = ObjectCreate(getPrototypeOf(objectOrArray));\n    const names = getOwnPropertyNames(objectOrArray);\n    return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce((seed, key) => {\n        const item = objectOrArray[key];\n        const original = unwrap$1(item);\n        if (original !== item) {\n            seed[key] = extract(original);\n        }\n        else {\n            seed[key] = item;\n        }\n        return seed;\n    }, obj);\n}\nconst formatter = {\n    header: (plainOrProxy) => {\n        const originalTarget = unwrap$1(plainOrProxy);\n        // if originalTarget is falsy or not unwrappable, exit\n        if (!originalTarget || originalTarget === plainOrProxy) {\n            return null;\n        }\n        const obj = extract(plainOrProxy);\n        return ['object', { object: obj }];\n    },\n    hasBody: () => {\n        return false;\n    },\n    body: () => {\n        return null;\n    },\n};\n// Inspired from paulmillr/es6-shim\n// https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L176-L185\n/* istanbul ignore next */\nfunction getGlobal() {\n    // the only reliable means to get the global object is `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof globalThis !== 'undefined') {\n        return globalThis;\n    }\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof __webpack_require__.g !== 'undefined') {\n        return __webpack_require__.g;\n    }\n    // Gracefully degrade if not able to locate the global object\n    return {};\n}\nfunction init$1() {\n    /* istanbul ignore if */\n    if (false) {}\n    const global = getGlobal();\n    // Custom Formatter for Dev Tools. To enable this, open Chrome Dev Tools\n    //  - Go to Settings,\n    //  - Under console, select \"Enable custom formatters\"\n    // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview\n    const devtoolsFormatters = global.devtoolsFormatters || [];\n    ArrayPush.call(devtoolsFormatters, formatter);\n    global.devtoolsFormatters = devtoolsFormatters;\n}\n\n/* istanbul ignore else */\nif (true) {\n    init$1();\n}\nfunction defaultValueIsObservable(value) {\n    // intentionally checking for null\n    if (value === null) {\n        return false;\n    }\n    // treat all non-object types, including undefined, as non-observable values\n    if (typeof value !== 'object') {\n        return false;\n    }\n    if (isArray(value)) {\n        return true;\n    }\n    const proto = getPrototypeOf(value);\n    return proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null;\n}\nconst defaultValueObserved = (obj, key) => {\n    /* do nothing */\n};\nconst defaultValueMutated = (obj, key) => {\n    /* do nothing */\n};\nfunction createShadowTarget(value) {\n    return isArray(value) ? [] : {};\n}\nclass ObservableMembrane {\n    constructor(options = {}) {\n        this.readOnlyObjectGraph = new WeakMap();\n        this.reactiveObjectGraph = new WeakMap();\n        const { valueMutated, valueObserved, valueIsObservable, tagPropertyKey } = options;\n        this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;\n        this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;\n        this.valueIsObservable = isFunction(valueIsObservable)\n            ? valueIsObservable\n            : defaultValueIsObservable;\n        this.tagPropertyKey = tagPropertyKey;\n    }\n    getProxy(value) {\n        const unwrappedValue = unwrap$1(value);\n        if (this.valueIsObservable(unwrappedValue)) {\n            // When trying to extract the writable version of a readonly we return the readonly.\n            if (this.readOnlyObjectGraph.get(unwrappedValue) === value) {\n                return value;\n            }\n            return this.getReactiveHandler(unwrappedValue);\n        }\n        return unwrappedValue;\n    }\n    getReadOnlyProxy(value) {\n        value = unwrap$1(value);\n        if (this.valueIsObservable(value)) {\n            return this.getReadOnlyHandler(value);\n        }\n        return value;\n    }\n    unwrapProxy(p) {\n        return unwrap$1(p);\n    }\n    getReactiveHandler(value) {\n        let proxy = this.reactiveObjectGraph.get(value);\n        if (isUndefined(proxy)) {\n            // caching the proxy after the first time it is accessed\n            const handler = new ReactiveProxyHandler(this, value);\n            proxy = new Proxy(createShadowTarget(value), handler);\n            registerProxy(proxy, value);\n            this.reactiveObjectGraph.set(value, proxy);\n        }\n        return proxy;\n    }\n    getReadOnlyHandler(value) {\n        let proxy = this.readOnlyObjectGraph.get(value);\n        if (isUndefined(proxy)) {\n            // caching the proxy after the first time it is accessed\n            const handler = new ReadOnlyHandler(this, value);\n            proxy = new Proxy(createShadowTarget(value), handler);\n            registerProxy(proxy, value);\n            this.readOnlyObjectGraph.set(value, proxy);\n        }\n        return proxy;\n    }\n}\n/** version: 2.0.0 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst lockerLivePropertyKey = Symbol.for('@@lockerLiveValue');\nconst reactiveMembrane = new ObservableMembrane({\n    valueObserved,\n    valueMutated,\n    tagPropertyKey: lockerLivePropertyKey,\n});\n/**\n * EXPERIMENTAL: This function implements an unwrap mechanism that\n * works for observable membrane objects. This API is subject to\n * change or being removed.\n */\nfunction unwrap(value) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    return reactiveMembrane.unwrapProxy(value) ;\n}\nfunction getReadOnlyProxy(value) {\n    // We must return a frozen wrapper around the value, so that child components cannot mutate properties passed to\n    // them from their parents. This applies to both the client and server.\n    return reactiveMembrane.getReadOnlyProxy(value);\n}\nfunction getReactiveProxy(value) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    return reactiveMembrane.getProxy(value) ;\n}\n// Making the component instance a live value when using Locker to support expandos.\nfunction markLockerLiveObject(obj) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    {\n        obj[lockerLivePropertyKey] = undefined;\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This operation is called with a descriptor of an standard html property\n * that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors\n * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.\n */\nfunction createBridgeToElementDescriptor(propName, descriptor) {\n    const { get, set, enumerable, configurable } = descriptor;\n    if (!isFunction$1(get)) {\n        if (true) {\n            assert.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard getter.`);\n        }\n        throw new TypeError();\n    }\n    if (!isFunction$1(set)) {\n        if (true) {\n            assert.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard setter.`);\n        }\n        throw new TypeError();\n    }\n    return {\n        enumerable,\n        configurable,\n        get() {\n            const vm = getAssociatedVM(this);\n            if (isBeingConstructed(vm)) {\n                if (true) {\n                    logError(`The value of property \\`${propName}\\` can't be read from the constructor because the owner component hasn't set the value yet. Instead, use the constructor to set a default value for the property.`, vm);\n                }\n                return;\n            }\n            componentValueObserved(vm, propName);\n            return get.call(vm.elm);\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (true) {\n                const vmBeingRendered = getVMBeingRendered();\n                assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);\n                assert.invariant(!isUpdatingTemplate, `When updating the template of ${vmBeingRendered}, one of the accessors used by the template has side effects on the state of ${vm}.${propName}`);\n                assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n                assert.invariant(!isObject(newValue) || isNull(newValue), `Invalid value \"${newValue}\" for \"${propName}\" of ${vm}. Value cannot be an object, must be a primitive value.`);\n            }\n            updateComponentValue(vm, propName, newValue);\n            return set.call(vm.elm, newValue);\n        },\n    };\n}\nconst refsCache = new WeakMap();\n/**\n * This class is the base class for any LWC element.\n * Some elements directly extends this class, others implement it via inheritance.\n **/\n// @ts-ignore\nconst LightningElement = function () {\n    // This should be as performant as possible, while any initialization should be done lazily\n    if (isNull(vmBeingConstructed)) {\n        // Thrown when doing something like `new LightningElement()` or\n        // `class Foo extends LightningElement {}; new Foo()`\n        throw new TypeError('Illegal constructor');\n    }\n    const vm = vmBeingConstructed;\n    const { def, elm } = vm;\n    const { bridge } = def;\n    if (true) {\n        const { assertInstanceOfHTMLElement } = vm.renderer;\n        assertInstanceOfHTMLElement(vm.elm, `Component creation requires a DOM element to be associated to ${vm}.`);\n    }\n    const component = this;\n    setPrototypeOf(elm, bridge.prototype);\n    vm.component = this;\n    // Locker hooks assignment. When the LWC engine run with Locker, Locker intercepts all the new\n    // component creation and passes hooks to instrument all the component interactions with the\n    // engine. We are intentionally hiding this argument from the formal API of LightningElement\n    // because we don't want folks to know about it just yet.\n    if (arguments.length === 1) {\n        const { callHook, setHook, getHook } = arguments[0];\n        vm.callHook = callHook;\n        vm.setHook = setHook;\n        vm.getHook = getHook;\n    }\n    markLockerLiveObject(this);\n    // Linking elm, shadow root and component with the VM.\n    associateVM(component, vm);\n    associateVM(elm, vm);\n    if (vm.renderMode === 1 /* RenderMode.Shadow */) {\n        vm.renderRoot = doAttachShadow(vm);\n    }\n    else {\n        vm.renderRoot = elm;\n    }\n    // Adding extra guard rails in DEV mode.\n    if (true) {\n        patchCustomElementWithRestrictions(elm);\n        patchComponentWithRestrictions(component);\n    }\n    return this;\n};\nfunction doAttachShadow(vm) {\n    const { elm, mode, shadowMode, def: { ctor }, renderer: { attachShadow }, } = vm;\n    const shadowRoot = attachShadow(elm, {\n        [KEY__SYNTHETIC_MODE]: shadowMode === 1 /* ShadowMode.Synthetic */,\n        delegatesFocus: Boolean(ctor.delegatesFocus),\n        mode,\n    });\n    vm.shadowRoot = shadowRoot;\n    associateVM(shadowRoot, vm);\n    if (true) {\n        patchShadowRootWithRestrictions(shadowRoot);\n    }\n    return shadowRoot;\n}\nfunction warnIfInvokedDuringConstruction(vm, methodOrPropName) {\n    if (isBeingConstructed(vm)) {\n        logError(`this.${methodOrPropName} should not be called during the construction of the custom element for ${getComponentTag(vm)} because the element is not yet in the DOM or has no children yet.`);\n    }\n}\n// @ts-ignore\nLightningElement.prototype = {\n    constructor: LightningElement,\n    dispatchEvent(event) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { dispatchEvent }, } = vm;\n        return dispatchEvent(elm, event);\n    },\n    addEventListener(type, listener, options) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { addEventListener }, } = vm;\n        if (true) {\n            const vmBeingRendered = getVMBeingRendered();\n            assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n            assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n            assert.invariant(isFunction$1(listener), `Invalid second argument for this.addEventListener() in ${vm} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n        }\n        const wrappedListener = getWrappedComponentsListener(vm, listener);\n        addEventListener(elm, type, wrappedListener, options);\n    },\n    removeEventListener(type, listener, options) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { removeEventListener }, } = vm;\n        const wrappedListener = getWrappedComponentsListener(vm, listener);\n        removeEventListener(elm, type, wrappedListener, options);\n    },\n    hasAttribute(name) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getAttribute }, } = vm;\n        return !isNull(getAttribute(elm, name));\n    },\n    hasAttributeNS(namespace, name) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getAttribute }, } = vm;\n        return !isNull(getAttribute(elm, name, namespace));\n    },\n    removeAttribute(name) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { removeAttribute }, } = vm;\n        unlockAttribute(elm, name);\n        removeAttribute(elm, name);\n        lockAttribute();\n    },\n    removeAttributeNS(namespace, name) {\n        const { elm, renderer: { removeAttribute }, } = getAssociatedVM(this);\n        unlockAttribute(elm, name);\n        removeAttribute(elm, name, namespace);\n        lockAttribute();\n    },\n    getAttribute(name) {\n        const vm = getAssociatedVM(this);\n        const { elm } = vm;\n        const { getAttribute } = vm.renderer;\n        return getAttribute(elm, name);\n    },\n    getAttributeNS(namespace, name) {\n        const vm = getAssociatedVM(this);\n        const { elm } = vm;\n        const { getAttribute } = vm.renderer;\n        return getAttribute(elm, name, namespace);\n    },\n    setAttribute(name, value) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { setAttribute }, } = vm;\n        if (true) {\n            assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n        }\n        unlockAttribute(elm, name);\n        setAttribute(elm, name, value);\n        lockAttribute();\n    },\n    setAttributeNS(namespace, name, value) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { setAttribute }, } = vm;\n        if (true) {\n            assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n        }\n        unlockAttribute(elm, name);\n        setAttribute(elm, name, value, namespace);\n        lockAttribute();\n    },\n    getBoundingClientRect() {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getBoundingClientRect }, } = vm;\n        if (true) {\n            warnIfInvokedDuringConstruction(vm, 'getBoundingClientRect()');\n        }\n        return getBoundingClientRect(elm);\n    },\n    get isConnected() {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { isConnected }, } = vm;\n        return isConnected(elm);\n    },\n    get classList() {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getClassList }, } = vm;\n        if (true) {\n            // TODO [#1290]: this still fails in dev but works in production, eventually, we should\n            // just throw in all modes\n            assert.isFalse(isBeingConstructed(vm), `Failed to construct ${vm}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`);\n        }\n        return getClassList(elm);\n    },\n    get template() {\n        const vm = getAssociatedVM(this);\n        if (true) {\n            if (vm.renderMode === 0 /* RenderMode.Light */) {\n                logError('`this.template` returns null for light DOM components. Since there is no shadow, the rendered content can be accessed via `this` itself. e.g. instead of `this.template.querySelector`, use `this.querySelector`.');\n            }\n        }\n        return vm.shadowRoot;\n    },\n    get refs() {\n        const vm = getAssociatedVM(this);\n        if (isUpdatingTemplate) {\n            if (true) {\n                logError(`this.refs should not be called while ${getComponentTag(vm)} is rendering. Use this.refs only when the DOM is stable, e.g. in renderedCallback().`);\n            }\n            // If the template is in the process of being updated, then we don't want to go through the normal\n            // process of returning the refs and caching them, because the state of the refs is unstable.\n            // This can happen if e.g. a template contains `<div class={foo}></div>` and `foo` is computed\n            // based on `this.refs.bar`.\n            return;\n        }\n        if (true) {\n            warnIfInvokedDuringConstruction(vm, 'refs');\n        }\n        const { refVNodes, cmpTemplate } = vm;\n        // If the `cmpTemplate` is null, that means that the template has not been rendered yet. Most likely this occurs\n        // if `this.refs` is called during the `connectedCallback` phase. The DOM elements have not been rendered yet,\n        // so log a warning. Note we also check `isBeingConstructed()` to avoid a double warning (due to\n        // `warnIfInvokedDuringConstruction` above).\n        if ( true &&\n            isNull(cmpTemplate) &&\n            !isBeingConstructed(vm)) {\n            logError(`this.refs is undefined for ${getComponentTag(vm)}. This is either because the attached template has no \"lwc:ref\" directive, or this.refs was ` +\n                `invoked before renderedCallback(). Use this.refs only when the referenced HTML elements have ` +\n                `been rendered to the DOM, such as within renderedCallback() or disconnectedCallback().`);\n        }\n        // For backwards compatibility with component written before template refs\n        // were introduced, we return undefined if the template has no refs defined\n        // anywhere. This fixes components that may want to add an expando called `refs`\n        // and are checking if it exists with `if (this.refs)`  before adding it.\n        // Note we use a null refVNodes to indicate that the template has no refs defined.\n        if (isNull(refVNodes)) {\n            return;\n        }\n        // The refNodes can be cached based on the refVNodes, since the refVNodes\n        // are recreated from scratch every time the template is rendered.\n        // This happens with `vm.refVNodes = null` in `template.ts` in `@lwc/engine-core`.\n        let refs = refsCache.get(refVNodes);\n        if (isUndefined$1(refs)) {\n            refs = create(null);\n            for (const key of keys(refVNodes)) {\n                refs[key] = refVNodes[key].elm;\n            }\n            freeze(refs);\n            refsCache.set(refVNodes, refs);\n        }\n        return refs;\n    },\n    // For backwards compat, we allow component authors to set `refs` as an expando\n    set refs(value) {\n        defineProperty(this, 'refs', {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value,\n        });\n    },\n    get shadowRoot() {\n        // From within the component instance, the shadowRoot is always reported as \"closed\".\n        // Authors should rely on this.template instead.\n        return null;\n    },\n    get children() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (true) {\n            warnIfInvokedDuringConstruction(vm, 'children');\n        }\n        return renderer.getChildren(vm.elm);\n    },\n    get childNodes() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (true) {\n            warnIfInvokedDuringConstruction(vm, 'childNodes');\n        }\n        return renderer.getChildNodes(vm.elm);\n    },\n    get firstChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (true) {\n            warnIfInvokedDuringConstruction(vm, 'firstChild');\n        }\n        return renderer.getFirstChild(vm.elm);\n    },\n    get firstElementChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (true) {\n            warnIfInvokedDuringConstruction(vm, 'firstElementChild');\n        }\n        return renderer.getFirstElementChild(vm.elm);\n    },\n    get lastChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (true) {\n            warnIfInvokedDuringConstruction(vm, 'lastChild');\n        }\n        return renderer.getLastChild(vm.elm);\n    },\n    get lastElementChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (true) {\n            warnIfInvokedDuringConstruction(vm, 'lastElementChild');\n        }\n        return renderer.getLastElementChild(vm.elm);\n    },\n    get ownerDocument() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (true) {\n            warnIfInvokedDuringConstruction(vm, 'ownerDocument');\n        }\n        return renderer.ownerDocument(vm.elm);\n    },\n    render() {\n        const vm = getAssociatedVM(this);\n        return vm.def.template;\n    },\n    toString() {\n        const vm = getAssociatedVM(this);\n        return `[object ${vm.def.name}]`;\n    },\n};\nconst queryAndChildGetterDescriptors = create(null);\nconst queryMethods = [\n    'getElementsByClassName',\n    'getElementsByTagName',\n    'querySelector',\n    'querySelectorAll',\n];\n// Generic passthrough for query APIs on HTMLElement to the relevant Renderer APIs\nfor (const queryMethod of queryMethods) {\n    queryAndChildGetterDescriptors[queryMethod] = {\n        value(arg) {\n            const vm = getAssociatedVM(this);\n            const { elm, renderer } = vm;\n            if (true) {\n                warnIfInvokedDuringConstruction(vm, `${queryMethod}()`);\n            }\n            return renderer[queryMethod](elm, arg);\n        },\n        configurable: true,\n        enumerable: true,\n        writable: true,\n    };\n}\ndefineProperties(LightningElement.prototype, queryAndChildGetterDescriptors);\nconst lightningBasedDescriptors = create(null);\nfor (const propName in HTMLElementOriginalDescriptors) {\n    lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);\n}\ndefineProperties(LightningElement.prototype, lightningBasedDescriptors);\nfunction applyAriaReflectionToLightningElement() {\n    // If ARIA reflection is not applied globally to Element.prototype, or if we are running server-side,\n    // apply it to LightningElement.prototype.\n    // This allows `this.aria*` property accessors to work from inside a component, and to reflect `aria-*` attrs.\n    applyAriaReflection(LightningElement.prototype);\n}\nif (lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {\n    applyAriaReflectionToLightningElement();\n}\ndefineProperty(LightningElement, 'CustomElementConstructor', {\n    get() {\n        // If required, a runtime-specific implementation must be defined.\n        throw new ReferenceError('The current runtime does not support CustomElementConstructor.');\n    },\n    configurable: true,\n});\nif (true) {\n    patchLightningElementPrototypeWithRestrictions(LightningElement.prototype);\n}\n\nfunction createObservedFieldPropertyDescriptor(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            componentValueObserved(vm, key);\n            return vm.cmpFields[key];\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            updateComponentValue(vm, key, newValue);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\n\n/*\n * Copyright (c) 2023, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst AdapterToTokenMap = new Map();\nfunction createContextProviderWithRegister(adapter, registerContextProvider) {\n    let adapterContextToken = AdapterToTokenMap.get(adapter);\n    if (!isUndefined$1(adapterContextToken)) {\n        throw new Error(`Adapter already has a context provider.`);\n    }\n    adapterContextToken = guid();\n    AdapterToTokenMap.set(adapter, adapterContextToken);\n    const providers = new WeakSet();\n    return (elmOrComponent, options) => {\n        if (providers.has(elmOrComponent)) {\n            throw new Error(`Adapter was already installed on ${elmOrComponent}.`);\n        }\n        providers.add(elmOrComponent);\n        const { consumerConnectedCallback, consumerDisconnectedCallback } = options;\n        registerContextProvider(elmOrComponent, adapterContextToken, (subscriptionPayload) => {\n            const { setNewContext, setDisconnectedCallback } = subscriptionPayload;\n            const consumer = {\n                provide(newContext) {\n                    setNewContext(newContext);\n                },\n            };\n            const disconnectCallback = () => {\n                if (!isUndefined$1(consumerDisconnectedCallback)) {\n                    consumerDisconnectedCallback(consumer);\n                }\n            };\n            setDisconnectedCallback(disconnectCallback);\n            consumerConnectedCallback(consumer);\n        });\n    };\n}\nfunction createContextWatcher(vm, wireDef, callbackWhenContextIsReady) {\n    const { adapter } = wireDef;\n    const adapterContextToken = AdapterToTokenMap.get(adapter);\n    if (isUndefined$1(adapterContextToken)) {\n        return; // no provider found, nothing to be done\n    }\n    const { elm, context: { wiredConnecting, wiredDisconnecting }, renderer: { registerContextConsumer }, } = vm;\n    // waiting for the component to be connected to formally request the context via the token\n    ArrayPush$1.call(wiredConnecting, () => {\n        // This will attempt to connect the current element with one of its anscestors\n        // that can provide context for the given wire adapter. This relationship is\n        // keyed on the secret & internal value of `adapterContextToken`, which is unique\n        // to a given wire adapter.\n        //\n        // Depending on the runtime environment, this connection is made using either DOM\n        // events (in the browser) or a custom traversal (on the server).\n        registerContextConsumer(elm, adapterContextToken, {\n            setNewContext(newContext) {\n                // eslint-disable-next-line @lwc/lwc-internal/no-invalid-todo\n                // TODO: dev-mode validation of config based on the adapter.contextSchema\n                callbackWhenContextIsReady(newContext);\n            },\n            setDisconnectedCallback(disconnectCallback) {\n                // adds this callback into the disconnect bucket so it gets disconnected from parent\n                // the the element hosting the wire is disconnected\n                ArrayPush$1.call(wiredDisconnecting, disconnectCallback);\n            },\n        });\n    });\n}\n\n/*\n * Copyright (c) 2023, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';\nconst DeprecatedWiredParamsMeta = '$$DeprecatedWiredParamsMetaKey$$';\nconst WIRE_DEBUG_ENTRY = '@wire';\nconst WireMetaMap = new Map();\nfunction createFieldDataCallback(vm, name) {\n    return (value) => {\n        updateComponentValue(vm, name, value);\n    };\n}\nfunction createMethodDataCallback(vm, method) {\n    return (value) => {\n        // dispatching new value into the wired method\n        runWithBoundaryProtection(vm, vm.owner, noop, () => {\n            // job\n            method.call(vm.component, value);\n        }, noop);\n    };\n}\nfunction createConfigWatcher(component, configCallback, callbackWhenConfigIsReady) {\n    let hasPendingConfig = false;\n    // creating the reactive observer for reactive params when needed\n    const ro = createReactiveObserver(() => {\n        if (hasPendingConfig === false) {\n            hasPendingConfig = true;\n            // collect new config in the micro-task\n            Promise.resolve().then(() => {\n                hasPendingConfig = false;\n                // resetting current reactive params\n                ro.reset();\n                // dispatching a new config due to a change in the configuration\n                computeConfigAndUpdate();\n            });\n        }\n    });\n    const computeConfigAndUpdate = () => {\n        let config;\n        ro.observe(() => (config = configCallback(component)));\n        // eslint-disable-next-line @lwc/lwc-internal/no-invalid-todo\n        // TODO: dev-mode validation of config based on the adapter.configSchema\n        // @ts-ignore it is assigned in the observe() callback\n        callbackWhenConfigIsReady(config);\n    };\n    return {\n        computeConfigAndUpdate,\n        ro,\n    };\n}\nfunction createConnector(vm, name, wireDef) {\n    const { method, adapter, configCallback, dynamic } = wireDef;\n    let debugInfo;\n    if (true) {\n        const wiredPropOrMethod = isUndefined$1(method) ? name : method.name;\n        debugInfo = create(null);\n        debugInfo.wasDataProvisionedForConfig = false;\n        vm.debugInfo[WIRE_DEBUG_ENTRY][wiredPropOrMethod] = debugInfo;\n    }\n    const fieldOrMethodCallback = isUndefined$1(method)\n        ? createFieldDataCallback(vm, name)\n        : createMethodDataCallback(vm, method);\n    const dataCallback = (value) => {\n        if (true) {\n            debugInfo.data = value;\n            // Note: most of the time, the data provided is for the current config, but there may be\n            // some conditions in which it does not, ex:\n            // race conditions in a poor network while the adapter does not cancel a previous request.\n            debugInfo.wasDataProvisionedForConfig = true;\n        }\n        fieldOrMethodCallback(value);\n    };\n    let context;\n    let connector;\n    // Workaround to pass the component element associated to this wire adapter instance.\n    defineProperty(dataCallback, DeprecatedWiredElementHost, {\n        value: vm.elm,\n    });\n    defineProperty(dataCallback, DeprecatedWiredParamsMeta, {\n        value: dynamic,\n    });\n    runWithBoundaryProtection(vm, vm, noop, () => {\n        // job\n        connector = new adapter(dataCallback);\n    }, noop);\n    const updateConnectorConfig = (config) => {\n        // every time the config is recomputed due to tracking,\n        // this callback will be invoked with the new computed config\n        runWithBoundaryProtection(vm, vm, noop, () => {\n            // job\n            if (true) {\n                debugInfo.config = config;\n                debugInfo.context = context;\n                debugInfo.wasDataProvisionedForConfig = false;\n            }\n            connector.update(config, context);\n        }, noop);\n    };\n    // Computes the current wire config and calls the update method on the wire adapter.\n    // If it has params, we will need to observe changes in the next tick.\n    const { computeConfigAndUpdate, ro } = createConfigWatcher(vm.component, configCallback, updateConnectorConfig);\n    // if the adapter needs contextualization, we need to watch for new context and push it alongside the config\n    if (!isUndefined$1(adapter.contextSchema)) {\n        createContextWatcher(vm, wireDef, (newContext) => {\n            // every time the context is pushed into this component,\n            // this callback will be invoked with the new computed context\n            if (context !== newContext) {\n                context = newContext;\n                // Note: when new context arrives, the config will be recomputed and pushed along side the new\n                // context, this is to preserve the identity characteristics, config should not have identity\n                // (ever), while context can have identity\n                if (vm.state === 1 /* VMState.connected */) {\n                    computeConfigAndUpdate();\n                }\n            }\n        });\n    }\n    return {\n        // @ts-ignore the boundary protection executes sync, connector is always defined\n        connector,\n        computeConfigAndUpdate,\n        resetConfigWatcher: () => ro.reset(),\n    };\n}\nfunction storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic) {\n    // support for callable adapters\n    if (adapter.adapter) {\n        adapter = adapter.adapter;\n    }\n    const method = descriptor.value;\n    const def = {\n        adapter,\n        method,\n        configCallback,\n        dynamic,\n    };\n    WireMetaMap.set(descriptor, def);\n}\nfunction storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic) {\n    // support for callable adapters\n    if (adapter.adapter) {\n        adapter = adapter.adapter;\n    }\n    const def = {\n        adapter,\n        configCallback,\n        dynamic,\n    };\n    WireMetaMap.set(descriptor, def);\n}\nfunction installWireAdapters(vm) {\n    const { context, def: { wire }, } = vm;\n    if (true) {\n        vm.debugInfo[WIRE_DEBUG_ENTRY] = create(null);\n    }\n    const wiredConnecting = (context.wiredConnecting = []);\n    const wiredDisconnecting = (context.wiredDisconnecting = []);\n    for (const fieldNameOrMethod in wire) {\n        const descriptor = wire[fieldNameOrMethod];\n        const wireDef = WireMetaMap.get(descriptor);\n        if (true) {\n            assert.invariant(wireDef, `Internal Error: invalid wire definition found.`);\n        }\n        if (!isUndefined$1(wireDef)) {\n            const { connector, computeConfigAndUpdate, resetConfigWatcher } = createConnector(vm, fieldNameOrMethod, wireDef);\n            const hasDynamicParams = wireDef.dynamic.length > 0;\n            ArrayPush$1.call(wiredConnecting, () => {\n                connector.connect();\n                if (!lwcRuntimeFlags.ENABLE_WIRE_SYNC_EMIT) {\n                    if (hasDynamicParams) {\n                        Promise.resolve().then(computeConfigAndUpdate);\n                        return;\n                    }\n                }\n                computeConfigAndUpdate();\n            });\n            ArrayPush$1.call(wiredDisconnecting, () => {\n                connector.disconnect();\n                resetConfigWatcher();\n            });\n        }\n    }\n}\nfunction connectWireAdapters(vm) {\n    const { wiredConnecting } = vm.context;\n    for (let i = 0, len = wiredConnecting.length; i < len; i += 1) {\n        wiredConnecting[i]();\n    }\n}\nfunction disconnectWireAdapters(vm) {\n    const { wiredDisconnecting } = vm.context;\n    runWithBoundaryProtection(vm, vm, noop, () => {\n        // job\n        for (let i = 0, len = wiredDisconnecting.length; i < len; i += 1) {\n            wiredDisconnecting[i]();\n        }\n    }, noop);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction api$1() {\n    if (true) {\n        assert.fail(`@api decorator can only be used as a decorator function.`);\n    }\n    throw new Error();\n}\nfunction createPublicPropertyDescriptor(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            if (isBeingConstructed(vm)) {\n                if (true) {\n                    logError(`Cant read the value of property \\`${toString$1(key)}\\` from the constructor because the owner component hasnt set the value yet. Instead, use the constructor to set a default value for the property.`, vm);\n                }\n                return;\n            }\n            componentValueObserved(vm, key);\n            return vm.cmpProps[key];\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (true) {\n                const vmBeingRendered = getVMBeingRendered();\n                assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString$1(key)}`);\n                assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString$1(key)}`);\n            }\n            vm.cmpProps[key] = newValue;\n            componentValueMutated(vm, key);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\nfunction createPublicAccessorDescriptor(key, descriptor) {\n    const { get, set, enumerable, configurable } = descriptor;\n    if (!isFunction$1(get)) {\n        if (true) {\n            assert.invariant(isFunction$1(get), `Invalid compiler output for public accessor ${toString$1(key)} decorated with @api`);\n        }\n        throw new Error();\n    }\n    return {\n        get() {\n            if (true) {\n                // Assert that the this value is an actual Component with an associated VM.\n                getAssociatedVM(this);\n            }\n            return get.call(this);\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (true) {\n                const vmBeingRendered = getVMBeingRendered();\n                assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString$1(key)}`);\n                assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString$1(key)}`);\n            }\n            if (set) {\n                set.call(this, newValue);\n            }\n            else if (true) {\n                assert.fail(`Invalid attempt to set a new value for property ${toString$1(key)} of ${vm} that does not has a setter decorated with @api.`);\n            }\n        },\n        enumerable,\n        configurable,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction track(target) {\n    if (arguments.length === 1) {\n        return getReactiveProxy(target);\n    }\n    if (true) {\n        assert.fail(`@track decorator can only be used with one argument to return a trackable object, or as a decorator function.`);\n    }\n    throw new Error();\n}\nfunction internalTrackDecorator(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            componentValueObserved(vm, key);\n            return vm.cmpFields[key];\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (true) {\n                const vmBeingRendered = getVMBeingRendered();\n                assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString$1(key)}`);\n                assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString$1(key)}`);\n            }\n            const reactiveOrAnyValue = getReactiveProxy(newValue);\n            updateComponentValue(vm, key, reactiveOrAnyValue);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * @wire decorator to wire fields and methods to a wire adapter in\n * LWC Components. This function implements the internals of this\n * decorator.\n */\nfunction wire(_adapter, _config) {\n    if (true) {\n        assert.fail('@wire(adapter, config?) may only be used as a decorator.');\n    }\n    throw new Error();\n}\nfunction internalWireFieldDecorator(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            componentValueObserved(vm, key);\n            return vm.cmpFields[key];\n        },\n        set(value) {\n            const vm = getAssociatedVM(this);\n            /**\n             * Reactivity for wired fields is provided in wiring.\n             * We intentionally add reactivity here since this is just\n             * letting the author to do the wrong thing, but it will keep our\n             * system to be backward compatible.\n             */\n            updateComponentValue(vm, key, value);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getClassDescriptorType(descriptor) {\n    if (isFunction$1(descriptor.value)) {\n        return \"method\" /* DescriptorType.Method */;\n    }\n    else if (isFunction$1(descriptor.set) || isFunction$1(descriptor.get)) {\n        return \"accessor\" /* DescriptorType.Accessor */;\n    }\n    else {\n        return \"field\" /* DescriptorType.Field */;\n    }\n}\nfunction validateObservedField(Ctor, fieldName, descriptor) {\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        const message = `Invalid observed ${fieldName} field. Found a duplicate ${type} with the same name.`;\n        // [W-9927596] Ideally we always throw an error when detecting duplicate observed field.\n        // This branch is only here for backward compatibility reasons.\n        if (type === \"accessor\" /* DescriptorType.Accessor */) {\n            logError(message);\n        }\n        else {\n            assert.fail(message);\n        }\n    }\n}\nfunction validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor) {\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        assert.fail(`Invalid @track ${fieldName} field. Found a duplicate ${type} with the same name.`);\n    }\n}\nfunction validateFieldDecoratedWithWire(Ctor, fieldName, descriptor) {\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        assert.fail(`Invalid @wire ${fieldName} field. Found a duplicate ${type} with the same name.`);\n    }\n}\nfunction validateMethodDecoratedWithWire(Ctor, methodName, descriptor) {\n    if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {\n        assert.fail(`Invalid @wire ${methodName} method.`);\n    }\n}\nfunction validateFieldDecoratedWithApi(Ctor, fieldName, descriptor) {\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        const message = `Invalid @api ${fieldName} field. Found a duplicate ${type} with the same name.`;\n        // [W-9927596] Ideally we always throw an error when detecting duplicate public properties.\n        // This branch is only here for backward compatibility reasons.\n        if (type === \"accessor\" /* DescriptorType.Accessor */) {\n            logError(message);\n        }\n        else {\n            assert.fail(message);\n        }\n    }\n}\nfunction validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor) {\n    if (isUndefined$1(descriptor)) {\n        assert.fail(`Invalid @api get ${fieldName} accessor.`);\n    }\n    else if (isFunction$1(descriptor.set)) {\n        assert.isTrue(isFunction$1(descriptor.get), `Missing getter for property ${fieldName} decorated with @api in ${Ctor}. You cannot have a setter without the corresponding getter.`);\n    }\n    else if (!isFunction$1(descriptor.get)) {\n        assert.fail(`Missing @api get ${fieldName} accessor.`);\n    }\n}\nfunction validateMethodDecoratedWithApi(Ctor, methodName, descriptor) {\n    if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {\n        assert.fail(`Invalid @api ${methodName} method.`);\n    }\n}\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by user-land code.\n */\nfunction registerDecorators(Ctor, meta) {\n    const proto = Ctor.prototype;\n    const { publicProps, publicMethods, wire, track, fields } = meta;\n    const apiMethods = create(null);\n    const apiFields = create(null);\n    const wiredMethods = create(null);\n    const wiredFields = create(null);\n    const observedFields = create(null);\n    const apiFieldsConfig = create(null);\n    let descriptor;\n    if (!isUndefined$1(publicProps)) {\n        for (const fieldName in publicProps) {\n            const propConfig = publicProps[fieldName];\n            apiFieldsConfig[fieldName] = propConfig.config;\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n            if (propConfig.config > 0) {\n                // accessor declaration\n                if (true) {\n                    validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor);\n                }\n                if (isUndefined$1(descriptor)) {\n                    throw new Error();\n                }\n                descriptor = createPublicAccessorDescriptor(fieldName, descriptor);\n            }\n            else {\n                // field declaration\n                if (true) {\n                    validateFieldDecoratedWithApi(Ctor, fieldName, descriptor);\n                }\n                // [W-9927596] If a component has both a public property and a private setter/getter\n                // with the same name, the property is defined as a public accessor. This branch is\n                // only here for backward compatibility reasons.\n                if (!isUndefined$1(descriptor) && !isUndefined$1(descriptor.get)) {\n                    descriptor = createPublicAccessorDescriptor(fieldName, descriptor);\n                }\n                else {\n                    descriptor = createPublicPropertyDescriptor(fieldName);\n                }\n            }\n            apiFields[fieldName] = descriptor;\n            defineProperty(proto, fieldName, descriptor);\n        }\n    }\n    if (!isUndefined$1(publicMethods)) {\n        forEach.call(publicMethods, (methodName) => {\n            descriptor = getOwnPropertyDescriptor$1(proto, methodName);\n            if (true) {\n                validateMethodDecoratedWithApi(Ctor, methodName, descriptor);\n            }\n            if (isUndefined$1(descriptor)) {\n                throw new Error();\n            }\n            apiMethods[methodName] = descriptor;\n        });\n    }\n    if (!isUndefined$1(wire)) {\n        for (const fieldOrMethodName in wire) {\n            const { adapter, method, config: configCallback, dynamic = [], } = wire[fieldOrMethodName];\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldOrMethodName);\n            if (method === 1) {\n                if (true) {\n                    assert.isTrue(adapter, `@wire on method \"${fieldOrMethodName}\": adapter id must be truthy.`);\n                    validateMethodDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);\n                }\n                if (isUndefined$1(descriptor)) {\n                    throw new Error();\n                }\n                wiredMethods[fieldOrMethodName] = descriptor;\n                storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic);\n            }\n            else {\n                if (true) {\n                    assert.isTrue(adapter, `@wire on field \"${fieldOrMethodName}\": adapter id must be truthy.`);\n                    validateFieldDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);\n                }\n                descriptor = internalWireFieldDecorator(fieldOrMethodName);\n                wiredFields[fieldOrMethodName] = descriptor;\n                storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic);\n                defineProperty(proto, fieldOrMethodName, descriptor);\n            }\n        }\n    }\n    if (!isUndefined$1(track)) {\n        for (const fieldName in track) {\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n            if (true) {\n                validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor);\n            }\n            descriptor = internalTrackDecorator(fieldName);\n            defineProperty(proto, fieldName, descriptor);\n        }\n    }\n    if (!isUndefined$1(fields)) {\n        for (let i = 0, n = fields.length; i < n; i++) {\n            const fieldName = fields[i];\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n            if (true) {\n                validateObservedField(Ctor, fieldName, descriptor);\n            }\n            // [W-9927596] Only mark a field as observed whenever it isn't a duplicated public nor\n            // tracked property. This is only here for backward compatibility purposes.\n            const isDuplicatePublicProp = !isUndefined$1(publicProps) && fieldName in publicProps;\n            const isDuplicateTrackedProp = !isUndefined$1(track) && fieldName in track;\n            if (!isDuplicatePublicProp && !isDuplicateTrackedProp) {\n                observedFields[fieldName] = createObservedFieldPropertyDescriptor(fieldName);\n            }\n        }\n    }\n    setDecoratorsMeta(Ctor, {\n        apiMethods,\n        apiFields,\n        apiFieldsConfig,\n        wiredMethods,\n        wiredFields,\n        observedFields,\n    });\n    return Ctor;\n}\nconst signedDecoratorToMetaMap = new Map();\nfunction setDecoratorsMeta(Ctor, meta) {\n    signedDecoratorToMetaMap.set(Ctor, meta);\n}\nconst defaultMeta = {\n    apiMethods: EmptyObject,\n    apiFields: EmptyObject,\n    apiFieldsConfig: EmptyObject,\n    wiredMethods: EmptyObject,\n    wiredFields: EmptyObject,\n    observedFields: EmptyObject,\n};\nfunction getDecoratorsMeta(Ctor) {\n    const meta = signedDecoratorToMetaMap.get(Ctor);\n    return isUndefined$1(meta) ? defaultMeta : meta;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet warned = false;\n// Only used in LWC's Karma tests\nif (false) {}\nfunction checkVersionMismatch(func, type) {\n    const versionMatcher = func.toString().match(LWC_VERSION_COMMENT_REGEX);\n    if (!isNull(versionMatcher) && !warned) {\n        const version = versionMatcher[1];\n        const [major, minor] = version.split('.');\n        const [expectedMajor, expectedMinor] = LWC_VERSION.split('.');\n        if (major !== expectedMajor || minor !== expectedMinor) {\n            warned = true; // only warn once to avoid flooding the console\n            // stylesheets and templates do not have user-meaningful names, but components do\n            const friendlyName = type === 'component' ? `${type} ${func.name}` : type;\n            logError(`LWC WARNING: current engine is v${LWC_VERSION}, but ${friendlyName} was compiled with v${version}.\\nPlease update your compiled code or LWC engine so that the versions match.\\nNo further warnings will appear.`);\n            report(\"CompilerRuntimeVersionMismatch\" /* ReportingEventId.CompilerRuntimeVersionMismatch */, {\n                compilerVersion: version,\n                runtimeVersion: LWC_VERSION,\n            });\n        }\n    }\n}\n\nconst signedTemplateSet = new Set();\nfunction defaultEmptyTemplate() {\n    return [];\n}\nsignedTemplateSet.add(defaultEmptyTemplate);\nfunction isTemplateRegistered(tpl) {\n    return signedTemplateSet.has(tpl);\n}\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\nfunction registerTemplate(tpl) {\n    if (true) {\n        checkVersionMismatch(tpl, 'template');\n    }\n    signedTemplateSet.add(tpl);\n    // chaining this method as a way to wrap existing\n    // assignment of templates easily, without too much transformation\n    return tpl;\n}\n/**\n * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar\n * libraries to sanitize vulnerable attributes.\n */\nfunction sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {\n    // locker-service patches this function during runtime to sanitize vulnerable attributes. When\n    // ran off-core this function becomes a noop and returns the user authored value.\n    return attrValue;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// A bridge descriptor is a descriptor whose job is just to get the component instance\n// from the element instance, and get the value or set a new value on the component.\n// This means that across different elements, similar names can get the exact same\n// descriptor, so we can cache them:\nconst cachedGetterByKey = create(null);\nconst cachedSetterByKey = create(null);\nfunction createGetter(key) {\n    let fn = cachedGetterByKey[key];\n    if (isUndefined$1(fn)) {\n        fn = cachedGetterByKey[key] = function () {\n            const vm = getAssociatedVM(this);\n            const { getHook } = vm;\n            return getHook(vm.component, key);\n        };\n    }\n    return fn;\n}\nfunction createSetter(key) {\n    let fn = cachedSetterByKey[key];\n    if (isUndefined$1(fn)) {\n        fn = cachedSetterByKey[key] = function (newValue) {\n            const vm = getAssociatedVM(this);\n            const { setHook } = vm;\n            newValue = getReadOnlyProxy(newValue);\n            setHook(vm.component, key, newValue);\n        };\n    }\n    return fn;\n}\nfunction createMethodCaller(methodName) {\n    return function () {\n        const vm = getAssociatedVM(this);\n        const { callHook, component } = vm;\n        const fn = component[methodName];\n        return callHook(vm.component, fn, ArraySlice.call(arguments));\n    };\n}\nfunction createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback) {\n    return function attributeChangedCallback(attrName, oldValue, newValue) {\n        if (oldValue === newValue) {\n            // Ignore same values.\n            return;\n        }\n        const propName = attributeToPropMap[attrName];\n        if (isUndefined$1(propName)) {\n            if (!isUndefined$1(superAttributeChangedCallback)) {\n                // delegate unknown attributes to the super.\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                superAttributeChangedCallback.apply(this, arguments);\n            }\n            return;\n        }\n        if (!isAttributeLocked(this, attrName)) {\n            // Ignore changes triggered by the engine itself during:\n            // * diffing when public props are attempting to reflect to the DOM\n            // * component via `this.setAttribute()`, should never update the prop\n            // Both cases, the setAttribute call is always wrapped by the unlocking of the\n            // attribute to be changed\n            return;\n        }\n        // Reflect attribute change to the corresponding property when changed from outside.\n        this[propName] = newValue;\n    };\n}\nfunction HTMLBridgeElementFactory(SuperClass, props, methods) {\n    let HTMLBridgeElement;\n    /**\n     * Modern browsers will have all Native Constructors as regular Classes\n     * and must be instantiated with the new keyword. In older browsers,\n     * specifically IE11, those are objects with a prototype property defined,\n     * since they are not supposed to be extended or instantiated with the\n     * new keyword. This forking logic supports both cases, specifically because\n     * wc.ts relies on the construction path of the bridges to create new\n     * fully qualifying web components.\n     */\n    if (isFunction$1(SuperClass)) {\n        HTMLBridgeElement = class extends SuperClass {\n        };\n    }\n    else {\n        HTMLBridgeElement = function () {\n            // Bridge classes are not supposed to be instantiated directly in\n            // browsers that do not support web components.\n            throw new TypeError('Illegal constructor');\n        };\n        // prototype inheritance dance\n        setPrototypeOf(HTMLBridgeElement, SuperClass);\n        setPrototypeOf(HTMLBridgeElement.prototype, SuperClass.prototype);\n        defineProperty(HTMLBridgeElement.prototype, 'constructor', {\n            writable: true,\n            configurable: true,\n            value: HTMLBridgeElement,\n        });\n    }\n    // generating the hash table for attributes to avoid duplicate fields and facilitate validation\n    // and false positives in case of inheritance.\n    const attributeToPropMap = create(null);\n    const { attributeChangedCallback: superAttributeChangedCallback } = SuperClass.prototype;\n    const { observedAttributes: superObservedAttributes = [] } = SuperClass;\n    const descriptors = create(null);\n    // expose getters and setters for each public props on the new Element Bridge\n    for (let i = 0, len = props.length; i < len; i += 1) {\n        const propName = props[i];\n        attributeToPropMap[htmlPropertyToAttribute(propName)] = propName;\n        descriptors[propName] = {\n            get: createGetter(propName),\n            set: createSetter(propName),\n            enumerable: true,\n            configurable: true,\n        };\n    }\n    // expose public methods as props on the new Element Bridge\n    for (let i = 0, len = methods.length; i < len; i += 1) {\n        const methodName = methods[i];\n        descriptors[methodName] = {\n            value: createMethodCaller(methodName),\n            writable: true,\n            configurable: true,\n        };\n    }\n    // creating a new attributeChangedCallback per bridge because they are bound to the corresponding\n    // map of attributes to props. We do this after all other props and methods to avoid the possibility\n    // of getting overrule by a class declaration in user-land, and we make it non-writable, non-configurable\n    // to preserve this definition.\n    descriptors.attributeChangedCallback = {\n        value: createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback),\n    };\n    // Specify attributes for which we want to reflect changes back to their corresponding\n    // properties via attributeChangedCallback.\n    defineProperty(HTMLBridgeElement, 'observedAttributes', {\n        get() {\n            return [...superObservedAttributes, ...keys(attributeToPropMap)];\n        },\n    });\n    defineProperties(HTMLBridgeElement.prototype, descriptors);\n    return HTMLBridgeElement;\n}\nconst BaseBridgeElement = HTMLBridgeElementFactory(HTMLElementConstructor, getOwnPropertyNames$1(HTMLElementOriginalDescriptors), []);\n{\n    // This ARIA reflection only really makes sense in the browser. On the server, there is no `renderedCallback()`,\n    // so you cannot do e.g. `this.template.querySelector('x-child').ariaBusy = 'true'`. So we don't need to expose\n    // ARIA props outside the LightningElement\n    if (lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {\n        // If ARIA reflection is not applied globally to Element.prototype, apply it to HTMLBridgeElement.prototype.\n        // This allows `elm.aria*` property accessors to work from outside a component, and to reflect `aria-*` attrs.\n        // This is especially important because the template compiler compiles aria-* attrs on components to aria* props\n        //\n        // Also note that we apply this to BaseBridgeElement.prototype to avoid excessively redefining property\n        // accessors inside the HTMLBridgeElementFactory.\n        applyAriaReflection(BaseBridgeElement.prototype);\n    }\n}\nfreeze(BaseBridgeElement);\nseal(BaseBridgeElement.prototype);\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst swappedTemplateMap = new WeakMap();\nconst swappedComponentMap = new WeakMap();\nconst swappedStyleMap = new WeakMap();\nconst activeTemplates = new WeakMap();\nconst activeComponents = new WeakMap();\nconst activeStyles = new WeakMap();\nfunction rehydrateHotTemplate(tpl) {\n    const list = activeTemplates.get(tpl);\n    if (!isUndefined$1(list)) {\n        list.forEach((vm) => {\n            if (isFalse(vm.isDirty)) {\n                // forcing the vm to rehydrate in the micro-task:\n                markComponentAsDirty(vm);\n                scheduleRehydration(vm);\n            }\n        });\n        // resetting the Set to release the memory of those vm references\n        // since they are not longer related to this template, instead\n        // they will get re-associated once these instances are rehydrated.\n        list.clear();\n    }\n    return true;\n}\nfunction rehydrateHotStyle(style) {\n    const list = activeStyles.get(style);\n    if (!isUndefined$1(list)) {\n        list.forEach((vm) => {\n            // if a style definition is swapped, we must reset\n            // vm's template content in the next micro-task:\n            forceRehydration(vm);\n        });\n        // resetting the Set to release the memory of those vm references\n        // since they are not longer related to this style, instead\n        // they will get re-associated once these instances are rehydrated.\n        list.clear();\n    }\n    return true;\n}\nfunction rehydrateHotComponent(Ctor) {\n    const list = activeComponents.get(Ctor);\n    let canRefreshAllInstances = true;\n    if (!isUndefined$1(list)) {\n        list.forEach((vm) => {\n            const { owner } = vm;\n            if (!isNull(owner)) {\n                // if a component class definition is swapped, we must reset\n                // owner's template content in the next micro-task:\n                forceRehydration(owner);\n            }\n            else {\n                // the hot swapping for components only work for instances of components\n                // created from a template, root elements can't be swapped because we\n                // don't have a way to force the creation of the element with the same state\n                // of the current element.\n                // Instead, we can report the problem to the caller so it can take action,\n                // for example: reload the entire page.\n                canRefreshAllInstances = false;\n            }\n        });\n        // resetting the Set to release the memory of those vm references\n        // since they are not longer related to this constructor, instead\n        // they will get re-associated once these instances are rehydrated.\n        list.clear();\n    }\n    return canRefreshAllInstances;\n}\nfunction getTemplateOrSwappedTemplate(tpl) {\n    assertNotProd(); // this method should never leak to prod\n    const visited = new Set();\n    while (swappedTemplateMap.has(tpl) && !visited.has(tpl)) {\n        visited.add(tpl);\n        tpl = swappedTemplateMap.get(tpl);\n    }\n    return tpl;\n}\nfunction getComponentOrSwappedComponent(Ctor) {\n    assertNotProd(); // this method should never leak to prod\n    const visited = new Set();\n    while (swappedComponentMap.has(Ctor) && !visited.has(Ctor)) {\n        visited.add(Ctor);\n        Ctor = swappedComponentMap.get(Ctor);\n    }\n    return Ctor;\n}\nfunction getStyleOrSwappedStyle(style) {\n    assertNotProd(); // this method should never leak to prod\n    const visited = new Set();\n    while (swappedStyleMap.has(style) && !visited.has(style)) {\n        visited.add(style);\n        style = swappedStyleMap.get(style);\n    }\n    return style;\n}\nfunction setActiveVM(vm) {\n    assertNotProd(); // this method should never leak to prod\n    // tracking active component\n    const Ctor = vm.def.ctor;\n    let componentVMs = activeComponents.get(Ctor);\n    if (isUndefined$1(componentVMs)) {\n        componentVMs = new Set();\n        activeComponents.set(Ctor, componentVMs);\n    }\n    // this will allow us to keep track of the hot components\n    componentVMs.add(vm);\n    // tracking active template\n    const tpl = vm.cmpTemplate;\n    if (tpl) {\n        let templateVMs = activeTemplates.get(tpl);\n        if (isUndefined$1(templateVMs)) {\n            templateVMs = new Set();\n            activeTemplates.set(tpl, templateVMs);\n        }\n        // this will allow us to keep track of the templates that are\n        // being used by a hot component\n        templateVMs.add(vm);\n        // tracking active styles associated to template\n        const stylesheets = tpl.stylesheets;\n        if (!isUndefined$1(stylesheets)) {\n            flattenStylesheets(stylesheets).forEach((stylesheet) => {\n                // this is necessary because we don't hold the list of styles\n                // in the vm, we only hold the selected (already swapped template)\n                // but the styles attached to the template might not be the actual\n                // active ones, but the swapped versions of those.\n                stylesheet = getStyleOrSwappedStyle(stylesheet);\n                let stylesheetVMs = activeStyles.get(stylesheet);\n                if (isUndefined$1(stylesheetVMs)) {\n                    stylesheetVMs = new Set();\n                    activeStyles.set(stylesheet, stylesheetVMs);\n                }\n                // this will allow us to keep track of the stylesheet that are\n                // being used by a hot component\n                stylesheetVMs.add(vm);\n            });\n        }\n    }\n}\nfunction removeActiveVM(vm) {\n    assertNotProd(); // this method should never leak to prod\n    // tracking inactive component\n    const Ctor = vm.def.ctor;\n    let list = activeComponents.get(Ctor);\n    if (!isUndefined$1(list)) {\n        // deleting the vm from the set to avoid leaking memory\n        list.delete(vm);\n    }\n    // removing inactive template\n    const tpl = vm.cmpTemplate;\n    if (tpl) {\n        list = activeTemplates.get(tpl);\n        if (!isUndefined$1(list)) {\n            // deleting the vm from the set to avoid leaking memory\n            list.delete(vm);\n        }\n        // removing active styles associated to template\n        const styles = tpl.stylesheets;\n        if (!isUndefined$1(styles)) {\n            flattenStylesheets(styles).forEach((style) => {\n                list = activeStyles.get(style);\n                if (!isUndefined$1(list)) {\n                    // deleting the vm from the set to avoid leaking memory\n                    list.delete(vm);\n                }\n            });\n        }\n    }\n}\nfunction swapTemplate(oldTpl, newTpl) {\n    if (true) {\n        if (isTemplateRegistered(oldTpl) && isTemplateRegistered(newTpl)) {\n            swappedTemplateMap.set(oldTpl, newTpl);\n            return rehydrateHotTemplate(oldTpl);\n        }\n        else {\n            throw new TypeError(`Invalid Template`);\n        }\n    }\n    return false;\n}\nfunction swapComponent(oldComponent, newComponent) {\n    if (true) {\n        if (isComponentConstructor(oldComponent) && isComponentConstructor(newComponent)) {\n            swappedComponentMap.set(oldComponent, newComponent);\n            return rehydrateHotComponent(oldComponent);\n        }\n        else {\n            throw new TypeError(`Invalid Component`);\n        }\n    }\n    return false;\n}\nfunction swapStyle(oldStyle, newStyle) {\n    if (true) {\n        // TODO [#1887]: once the support for registering styles is implemented\n        // we can add the validation of both styles around this block.\n        swappedStyleMap.set(oldStyle, newStyle);\n        return rehydrateHotStyle(oldStyle);\n    }\n    return false;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CtorToDefMap = new WeakMap();\nfunction getCtorProto(Ctor) {\n    let proto = getPrototypeOf$1(Ctor);\n    if (isNull(proto)) {\n        throw new ReferenceError(`Invalid prototype chain for ${Ctor.name}, you must extend LightningElement.`);\n    }\n    // covering the cases where the ref is circular in AMD\n    if (isCircularModuleDependency(proto)) {\n        const p = resolveCircularModuleDependency(proto);\n        if (true) {\n            if (isNull(p)) {\n                throw new ReferenceError(`Circular module dependency for ${Ctor.name}, must resolve to a constructor that extends LightningElement.`);\n            }\n        }\n        // escape hatch for Locker and other abstractions to provide their own base class instead\n        // of our Base class without having to leak it to user-land. If the circular function returns\n        // itself, that's the signal that we have hit the end of the proto chain, which must always\n        // be base.\n        proto = p === proto ? LightningElement : p;\n    }\n    return proto;\n}\nfunction createComponentDef(Ctor) {\n    const { shadowSupportMode: ctorShadowSupportMode, renderMode: ctorRenderMode } = Ctor;\n    if (true) {\n        const ctorName = Ctor.name;\n        // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.\n        // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a \"name\" property with string value, but found ${ctorName}.`);\n        assert.isTrue(Ctor.constructor, `Missing ${ctorName}.constructor, ${ctorName} should have a \"constructor\" property.`);\n        if (!isUndefined$1(ctorShadowSupportMode)) {\n            assert.invariant(ctorShadowSupportMode === \"any\" /* ShadowSupportMode.Any */ ||\n                ctorShadowSupportMode === \"reset\" /* ShadowSupportMode.Default */, `Invalid value for static property shadowSupportMode: '${ctorShadowSupportMode}'`);\n        }\n        if (!isUndefined$1(ctorRenderMode)) {\n            assert.invariant(ctorRenderMode === 'light' || ctorRenderMode === 'shadow', `Invalid value for static property renderMode: '${ctorRenderMode}'. renderMode must be either 'light' or 'shadow'.`);\n        }\n    }\n    const decoratorsMeta = getDecoratorsMeta(Ctor);\n    const { apiFields, apiFieldsConfig, apiMethods, wiredFields, wiredMethods, observedFields } = decoratorsMeta;\n    const proto = Ctor.prototype;\n    let { connectedCallback, disconnectedCallback, renderedCallback, errorCallback, render } = proto;\n    const superProto = getCtorProto(Ctor);\n    const superDef = superProto !== LightningElement ? getComponentInternalDef(superProto) : lightingElementDef;\n    const bridge = HTMLBridgeElementFactory(superDef.bridge, keys(apiFields), keys(apiMethods));\n    const props = assign(create(null), superDef.props, apiFields);\n    const propsConfig = assign(create(null), superDef.propsConfig, apiFieldsConfig);\n    const methods = assign(create(null), superDef.methods, apiMethods);\n    const wire = assign(create(null), superDef.wire, wiredFields, wiredMethods);\n    connectedCallback = connectedCallback || superDef.connectedCallback;\n    disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;\n    renderedCallback = renderedCallback || superDef.renderedCallback;\n    errorCallback = errorCallback || superDef.errorCallback;\n    render = render || superDef.render;\n    let shadowSupportMode = superDef.shadowSupportMode;\n    if (!isUndefined$1(ctorShadowSupportMode)) {\n        shadowSupportMode = ctorShadowSupportMode;\n    }\n    let renderMode = superDef.renderMode;\n    if (!isUndefined$1(ctorRenderMode)) {\n        renderMode = ctorRenderMode === 'light' ? 0 /* RenderMode.Light */ : 1 /* RenderMode.Shadow */;\n    }\n    const template = getComponentRegisteredTemplate(Ctor) || superDef.template;\n    const name = Ctor.name || superDef.name;\n    // installing observed fields into the prototype.\n    defineProperties(proto, observedFields);\n    const def = {\n        ctor: Ctor,\n        name,\n        wire,\n        props,\n        propsConfig,\n        methods,\n        bridge,\n        template,\n        renderMode,\n        shadowSupportMode,\n        connectedCallback,\n        disconnectedCallback,\n        renderedCallback,\n        errorCallback,\n        render,\n    };\n    if (true) {\n        freeze(Ctor.prototype);\n    }\n    return def;\n}\n/**\n * EXPERIMENTAL: This function allows for the identification of LWC constructors. This API is\n * subject to change or being removed.\n */\nfunction isComponentConstructor(ctor) {\n    if (!isFunction$1(ctor)) {\n        return false;\n    }\n    // Fast path: LightningElement is part of the prototype chain of the constructor.\n    if (ctor.prototype instanceof LightningElement) {\n        return true;\n    }\n    // Slow path: LightningElement is not part of the prototype chain of the constructor, we need\n    // climb up the constructor prototype chain to check in case there are circular dependencies\n    // to resolve.\n    let current = ctor;\n    do {\n        if (isCircularModuleDependency(current)) {\n            const circularResolved = resolveCircularModuleDependency(current);\n            // If the circular function returns itself, that's the signal that we have hit the end\n            // of the proto chain, which must always be a valid base constructor.\n            if (circularResolved === current) {\n                return true;\n            }\n            current = circularResolved;\n        }\n        if (current === LightningElement) {\n            return true;\n        }\n    } while (!isNull(current) && (current = getPrototypeOf$1(current)));\n    // Finally return false if the LightningElement is not part of the prototype chain.\n    return false;\n}\nfunction getComponentInternalDef(Ctor) {\n    if (true) {\n        Ctor = getComponentOrSwappedComponent(Ctor);\n    }\n    let def = CtorToDefMap.get(Ctor);\n    if (isUndefined$1(def)) {\n        if (isCircularModuleDependency(Ctor)) {\n            const resolvedCtor = resolveCircularModuleDependency(Ctor);\n            def = getComponentInternalDef(resolvedCtor);\n            // Cache the unresolved component ctor too. The next time if the same unresolved ctor is used,\n            // look up the definition in cache instead of re-resolving and recreating the def.\n            CtorToDefMap.set(Ctor, def);\n            return def;\n        }\n        if (!isComponentConstructor(Ctor)) {\n            throw new TypeError(`${Ctor} is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration.`);\n        }\n        def = createComponentDef(Ctor);\n        CtorToDefMap.set(Ctor, def);\n    }\n    return def;\n}\nfunction getComponentHtmlPrototype(Ctor) {\n    const def = getComponentInternalDef(Ctor);\n    return def.bridge;\n}\nconst lightingElementDef = {\n    ctor: LightningElement,\n    name: LightningElement.name,\n    props: lightningBasedDescriptors,\n    propsConfig: EmptyObject,\n    methods: EmptyObject,\n    renderMode: 1 /* RenderMode.Shadow */,\n    shadowSupportMode: \"reset\" /* ShadowSupportMode.Default */,\n    wire: EmptyObject,\n    bridge: BaseBridgeElement,\n    template: defaultEmptyTemplate,\n    render: LightningElement.prototype.render,\n};\n/**\n * EXPERIMENTAL: This function allows for the collection of internal component metadata. This API is\n * subject to change or being removed.\n */\nfunction getComponentDef(Ctor) {\n    const def = getComponentInternalDef(Ctor);\n    // From the internal def object, we need to extract the info that is useful\n    // for some external services, e.g.: Locker Service, usually, all they care\n    // is about the shape of the constructor, the internals of it are not relevant\n    // because they don't have a way to mess with that.\n    const { ctor, name, props, propsConfig, methods } = def;\n    const publicProps = {};\n    for (const key in props) {\n        // avoid leaking the reference to the public props descriptors\n        publicProps[key] = {\n            config: propsConfig[key] || 0,\n            type: \"any\" /* PropDefType.any */,\n            attr: htmlPropertyToAttribute(key),\n        };\n    }\n    const publicMethods = {};\n    for (const key in methods) {\n        // avoid leaking the reference to the public method descriptors\n        publicMethods[key] = methods[key].value;\n    }\n    return {\n        ctor,\n        name,\n        props: publicProps,\n        methods: publicMethods,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction makeHostToken(token) {\n    return `${token}-host`;\n}\nfunction createInlineStyleVNode(content) {\n    return api.h('style', {\n        key: 'style',\n        attrs: {\n            type: 'text/css',\n        },\n    }, [api.t(content)]);\n}\nfunction updateStylesheetToken(vm, template) {\n    const { elm, context, renderMode, shadowMode, renderer: { getClassList, removeAttribute, setAttribute }, } = vm;\n    const { stylesheets: newStylesheets, stylesheetToken: newStylesheetToken } = template;\n    const { stylesheets: newVmStylesheets } = vm;\n    const isSyntheticShadow = renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 1 /* ShadowMode.Synthetic */;\n    const { hasScopedStyles } = context;\n    let newToken;\n    let newHasTokenInClass;\n    let newHasTokenInAttribute;\n    // Reset the styling token applied to the host element.\n    const { stylesheetToken: oldToken, hasTokenInClass: oldHasTokenInClass, hasTokenInAttribute: oldHasTokenInAttribute, } = context;\n    if (!isUndefined$1(oldToken)) {\n        if (oldHasTokenInClass) {\n            getClassList(elm).remove(makeHostToken(oldToken));\n        }\n        if (oldHasTokenInAttribute) {\n            removeAttribute(elm, makeHostToken(oldToken));\n        }\n    }\n    // Apply the new template styling token to the host element, if the new template has any\n    // associated stylesheets. In the case of light DOM, also ensure there is at least one scoped stylesheet.\n    const hasNewStylesheets = hasStyles(newStylesheets);\n    const hasNewVmStylesheets = hasStyles(newVmStylesheets);\n    if (hasNewStylesheets || hasNewVmStylesheets) {\n        newToken = newStylesheetToken;\n    }\n    // Set the new styling token on the host element\n    if (!isUndefined$1(newToken)) {\n        if (hasScopedStyles) {\n            getClassList(elm).add(makeHostToken(newToken));\n            newHasTokenInClass = true;\n        }\n        if (isSyntheticShadow) {\n            setAttribute(elm, makeHostToken(newToken), '');\n            newHasTokenInAttribute = true;\n        }\n    }\n    // Update the styling tokens present on the context object.\n    context.stylesheetToken = newToken;\n    context.hasTokenInClass = newHasTokenInClass;\n    context.hasTokenInAttribute = newHasTokenInAttribute;\n}\nfunction evaluateStylesheetsContent(stylesheets, stylesheetToken, vm) {\n    const content = [];\n    let root;\n    for (let i = 0; i < stylesheets.length; i++) {\n        let stylesheet = stylesheets[i];\n        if (isArray$1(stylesheet)) {\n            ArrayPush$1.apply(content, evaluateStylesheetsContent(stylesheet, stylesheetToken, vm));\n        }\n        else {\n            if (true) {\n                // Check for compiler version mismatch in dev mode only\n                checkVersionMismatch(stylesheet, 'stylesheet');\n                // in dev-mode, we support hot swapping of stylesheet, which means that\n                // the component instance might be attempting to use an old version of\n                // the stylesheet, while internally, we have a replacement for it.\n                stylesheet = getStyleOrSwappedStyle(stylesheet);\n            }\n            const isScopedCss = stylesheet[KEY__SCOPED_CSS];\n            if (lwcRuntimeFlags.DISABLE_LIGHT_DOM_UNSCOPED_CSS &&\n                !isScopedCss &&\n                vm.renderMode === 0 /* RenderMode.Light */) {\n                logError('Unscoped CSS is not supported in Light DOM. Please use scoped CSS (*.scoped.css) instead of unscoped CSS (*.css).');\n                continue;\n            }\n            // Apply the scope token only if the stylesheet itself is scoped, or if we're rendering synthetic shadow.\n            const scopeToken = isScopedCss ||\n                (vm.shadowMode === 1 /* ShadowMode.Synthetic */ && vm.renderMode === 1 /* RenderMode.Shadow */)\n                ? stylesheetToken\n                : undefined;\n            // Use the actual `:host` selector if we're rendering global CSS for light DOM, or if we're rendering\n            // native shadow DOM. Synthetic shadow DOM never uses `:host`.\n            const useActualHostSelector = vm.renderMode === 0 /* RenderMode.Light */\n                ? !isScopedCss\n                : vm.shadowMode === 0 /* ShadowMode.Native */;\n            // Use the native :dir() pseudoclass only in native shadow DOM. Otherwise, in synthetic shadow,\n            // we use an attribute selector on the host to simulate :dir().\n            let useNativeDirPseudoclass;\n            if (vm.renderMode === 1 /* RenderMode.Shadow */) {\n                useNativeDirPseudoclass = vm.shadowMode === 0 /* ShadowMode.Native */;\n            }\n            else {\n                // Light DOM components should only render `[dir]` if they're inside of a synthetic shadow root.\n                // At the top level (root is null) or inside of a native shadow root, they should use `:dir()`.\n                if (isUndefined$1(root)) {\n                    // Only calculate the root once as necessary\n                    root = getNearestShadowComponent(vm);\n                }\n                useNativeDirPseudoclass = isNull(root) || root.shadowMode === 0 /* ShadowMode.Native */;\n            }\n            ArrayPush$1.call(content, stylesheet(scopeToken, useActualHostSelector, useNativeDirPseudoclass));\n        }\n    }\n    return content;\n}\nfunction getStylesheetsContent(vm, template) {\n    const { stylesheets, stylesheetToken } = template;\n    const { stylesheets: vmStylesheets } = vm;\n    let content = [];\n    if (hasStyles(stylesheets)) {\n        content = evaluateStylesheetsContent(stylesheets, stylesheetToken, vm);\n    }\n    // VM (component) stylesheets apply after template stylesheets\n    if (hasStyles(vmStylesheets)) {\n        ArrayPush$1.apply(content, evaluateStylesheetsContent(vmStylesheets, stylesheetToken, vm));\n    }\n    return content;\n}\n// It might be worth caching this to avoid doing the lookup repeatedly, but\n// perf testing has not shown it to be a huge improvement yet:\n// https://github.com/salesforce/lwc/pull/2460#discussion_r691208892\nfunction getNearestShadowComponent(vm) {\n    let owner = vm;\n    while (!isNull(owner)) {\n        if (owner.renderMode === 1 /* RenderMode.Shadow */) {\n            return owner;\n        }\n        owner = owner.owner;\n    }\n    return owner;\n}\n/**\n * If the component that is currently being rendered uses scoped styles,\n * this returns the unique token for that scoped stylesheet. Otherwise\n * it returns null.\n */\nfunction getScopeTokenClass(owner) {\n    const { cmpTemplate, context } = owner;\n    return (context.hasScopedStyles && (cmpTemplate === null || cmpTemplate === void 0 ? void 0 : cmpTemplate.stylesheetToken)) || null;\n}\n/**\n * This function returns the host style token for a custom element if it\n * exists. Otherwise it returns null.\n *\n * A host style token is applied to the component if scoped styles are used.\n */\nfunction getStylesheetTokenHost(vnode) {\n    const { template } = getComponentInternalDef(vnode.ctor);\n    const { vm } = vnode;\n    const { stylesheetToken } = template;\n    return !isUndefined$1(stylesheetToken) && computeHasScopedStyles(template, vm)\n        ? makeHostToken(stylesheetToken)\n        : null;\n}\nfunction getNearestNativeShadowComponent(vm) {\n    const owner = getNearestShadowComponent(vm);\n    if (!isNull(owner) && owner.shadowMode === 1 /* ShadowMode.Synthetic */) {\n        // Synthetic-within-native is impossible. So if the nearest shadow component is\n        // synthetic, we know we won't find a native component if we go any further.\n        return null;\n    }\n    return owner;\n}\nfunction createStylesheet(vm, stylesheets) {\n    const { renderMode, shadowMode, renderer: { insertStylesheet }, } = vm;\n    if (renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 1 /* ShadowMode.Synthetic */) {\n        for (let i = 0; i < stylesheets.length; i++) {\n            insertStylesheet(stylesheets[i]);\n        }\n    }\n    else if (vm.hydrated) {\n        // Note: We need to ensure that during hydration, the stylesheets method is the same as those in ssr.\n        //       This works in the client, because the stylesheets are created, and cached in the VM\n        //       the first time the VM renders.\n        // native shadow or light DOM, SSR\n        return ArrayMap.call(stylesheets, createInlineStyleVNode);\n    }\n    else {\n        // native shadow or light DOM, DOM renderer\n        const root = getNearestNativeShadowComponent(vm);\n        // null root means a global style\n        const target = isNull(root) ? undefined : root.shadowRoot;\n        for (let i = 0; i < stylesheets.length; i++) {\n            insertStylesheet(stylesheets[i], target);\n        }\n    }\n    return null;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction isVBaseElement(vnode) {\n    const { type } = vnode;\n    return type === 2 /* VNodeType.Element */ || type === 3 /* VNodeType.CustomElement */;\n}\nfunction isSameVnode(vnode1, vnode2) {\n    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\nfunction isVCustomElement(vnode) {\n    return vnode.type === 3 /* VNodeType.CustomElement */;\n}\nfunction isVFragment(vnode) {\n    return vnode.type === 5 /* VNodeType.Fragment */;\n}\nfunction isVScopedSlotFragment(vnode) {\n    return vnode.type === 6 /* VNodeType.ScopedSlotFragment */;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ColonCharCode$1 = 58;\nfunction patchAttributes(oldVnode, vnode, renderer) {\n    const { attrs } = vnode.data;\n    if (isUndefined$1(attrs)) {\n        return;\n    }\n    const oldAttrs = isNull(oldVnode) ? EmptyObject : oldVnode.data.attrs;\n    if (oldAttrs === attrs) {\n        return;\n    }\n    const { elm } = vnode;\n    const { setAttribute, removeAttribute } = renderer;\n    for (const key in attrs) {\n        const cur = attrs[key];\n        const old = oldAttrs[key];\n        if (old !== cur) {\n            unlockAttribute(elm, key);\n            if (StringCharCodeAt.call(key, 3) === ColonCharCode$1) {\n                // Assume xml namespace\n                setAttribute(elm, key, cur, XML_NAMESPACE);\n            }\n            else if (StringCharCodeAt.call(key, 5) === ColonCharCode$1) {\n                // Assume xlink namespace\n                setAttribute(elm, key, cur, XLINK_NAMESPACE);\n            }\n            else if (isNull(cur) || isUndefined$1(cur)) {\n                removeAttribute(elm, key);\n            }\n            else {\n                setAttribute(elm, key, cur);\n            }\n            lockAttribute();\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ColonCharCode = 58;\nfunction patchAttrUnlessProp(oldVnode, vnode, renderer) {\n    const { data: { attrs }, elm, } = vnode;\n    if (isUndefined$1(attrs)) {\n        return;\n    }\n    const { removeAttribute, setAttribute, setProperty } = renderer;\n    const oldAttrs = isNull(oldVnode) ? EmptyObject : oldVnode.data.attrs;\n    for (const name in attrs) {\n        const cur = attrs[name];\n        const old = oldAttrs[name];\n        if (old !== cur) {\n            const propName = htmlAttributeToProperty(name);\n            if (propName in elm) {\n                setProperty(elm, name, cur);\n            }\n            else if (StringCharCodeAt.call(name, 3) === ColonCharCode) {\n                // Assume xml namespace\n                setAttribute(elm, name, cur, XML_NAMESPACE);\n            }\n            else if (StringCharCodeAt.call(name, 5) === ColonCharCode) {\n                // Assume xlink namespace\n                setAttribute(elm, name, cur, XLINK_NAMESPACE);\n            }\n            else if (isNull(cur) || isUndefined$1(cur)) {\n                removeAttribute(elm, name);\n            }\n            else {\n                setAttribute(elm, name, cur);\n            }\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction isLiveBindingProp(sel, key) {\n    // For properties with live bindings, we read values from the DOM element\n    // instead of relying on internally tracked values.\n    return sel === 'input' && (key === 'value' || key === 'checked');\n}\nfunction patchProps(oldVnode, vnode, renderer) {\n    let { props } = vnode.data;\n    const { spread } = vnode.data;\n    if (isUndefined$1(props) && isUndefined$1(spread)) {\n        return;\n    }\n    let oldProps;\n    if (!isNull(oldVnode)) {\n        oldProps = oldVnode.data.props;\n        const oldSpread = oldVnode.data.spread;\n        if (oldProps === props && oldSpread === spread) {\n            return;\n        }\n        if (isUndefined$1(oldProps)) {\n            oldProps = EmptyObject;\n        }\n        if (!isUndefined$1(oldSpread)) {\n            oldProps = assign({}, oldProps, oldSpread);\n        }\n    }\n    if (!isUndefined$1(spread)) {\n        props = assign({}, props, spread);\n    }\n    const isFirstPatch = isNull(oldVnode);\n    const { elm, sel } = vnode;\n    const { getProperty, setProperty } = renderer;\n    for (const key in props) {\n        const cur = props[key];\n        // Set the property if it's the first time is is patched or if the previous property is\n        // different than the one previously set.\n        if (isFirstPatch ||\n            cur !== (isLiveBindingProp(sel, key) ? getProperty(elm, key) : oldProps[key]) ||\n            !(key in oldProps) // this is required because the above case will pass when `cur` is `undefined` and key is missing in `oldProps`\n        ) {\n            // Additional verification if properties are supported by the element\n            // Validation relies on html properties and public properties being defined on the element,\n            // SSR has its own custom validation.\n            if (true) {\n                if (!(key in elm)) {\n                    logWarn(`Unknown public property \"${key}\" of element <${elm.tagName.toLowerCase()}>. This is either a typo on the corresponding attribute \"${htmlPropertyToAttribute(key)}\", or the attribute does not exist in this browser or DOM implementation.`);\n                }\n            }\n            setProperty(elm, key, cur);\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst classNameToClassMap = create(null);\nfunction getMapFromClassName(className) {\n    // Intentionally using == to match undefined and null values from computed style attribute\n    if (className == null) {\n        return EmptyObject;\n    }\n    // computed class names must be string\n    className = isString(className) ? className : className + '';\n    let map = classNameToClassMap[className];\n    if (map) {\n        return map;\n    }\n    map = create(null);\n    let start = 0;\n    let o;\n    const len = className.length;\n    for (o = 0; o < len; o++) {\n        if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {\n            if (o > start) {\n                map[StringSlice.call(className, start, o)] = true;\n            }\n            start = o + 1;\n        }\n    }\n    if (o > start) {\n        map[StringSlice.call(className, start, o)] = true;\n    }\n    classNameToClassMap[className] = map;\n    if (true) {\n        // just to make sure that this object never changes as part of the diffing algo\n        freeze(map);\n    }\n    return map;\n}\nfunction patchClassAttribute(oldVnode, vnode, renderer) {\n    const { elm, data: { className: newClass }, } = vnode;\n    const oldClass = isNull(oldVnode) ? undefined : oldVnode.data.className;\n    if (oldClass === newClass) {\n        return;\n    }\n    const { getClassList } = renderer;\n    const classList = getClassList(elm);\n    const newClassMap = getMapFromClassName(newClass);\n    const oldClassMap = getMapFromClassName(oldClass);\n    let name;\n    for (name in oldClassMap) {\n        // remove only if it is not in the new class collection and it is not set from within the instance\n        if (isUndefined$1(newClassMap[name])) {\n            classList.remove(name);\n        }\n    }\n    for (name in newClassMap) {\n        if (isUndefined$1(oldClassMap[name])) {\n            classList.add(name);\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The style property is a string when defined via an expression in the template.\nfunction patchStyleAttribute(oldVnode, vnode, renderer) {\n    const { elm, data: { style: newStyle }, } = vnode;\n    const oldStyle = isNull(oldVnode) ? undefined : oldVnode.data.style;\n    if (oldStyle === newStyle) {\n        return;\n    }\n    const { setAttribute, removeAttribute } = renderer;\n    if (!isString(newStyle) || newStyle === '') {\n        removeAttribute(elm, 'style');\n    }\n    else {\n        setAttribute(elm, 'style', newStyle);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction applyEventListeners(vnode, renderer) {\n    const { elm, data: { on }, } = vnode;\n    if (isUndefined$1(on)) {\n        return;\n    }\n    const { addEventListener } = renderer;\n    for (const name in on) {\n        const handler = on[name];\n        addEventListener(elm, name, handler);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The HTML class property becomes the vnode.data.classMap object when defined as a string in the template.\n// The compiler takes care of transforming the inline classnames into an object. It's faster to set the\n// different classnames properties individually instead of via a string.\nfunction applyStaticClassAttribute(vnode, renderer) {\n    const { elm, data: { classMap }, } = vnode;\n    if (isUndefined$1(classMap)) {\n        return;\n    }\n    const { getClassList } = renderer;\n    const classList = getClassList(elm);\n    for (const name in classMap) {\n        classList.add(name);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The HTML style property becomes the vnode.data.styleDecls object when defined as a string in the template.\n// The compiler takes care of transforming the inline style into an object. It's faster to set the\n// different style properties individually instead of via a string.\nfunction applyStaticStyleAttribute(vnode, renderer) {\n    const { elm, data: { styleDecls }, } = vnode;\n    if (isUndefined$1(styleDecls)) {\n        return;\n    }\n    const { setCSSStyleProperty } = renderer;\n    for (let i = 0; i < styleDecls.length; i++) {\n        const [prop, value, important] = styleDecls[i];\n        setCSSStyleProperty(elm, prop, value, important);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction patchChildren(c1, c2, parent, renderer) {\n    if (hasDynamicChildren(c2)) {\n        updateDynamicChildren(c1, c2, parent, renderer);\n    }\n    else {\n        updateStaticChildren(c1, c2, parent, renderer);\n    }\n}\nfunction patch(n1, n2, parent, renderer) {\n    var _a, _b;\n    if (n1 === n2) {\n        return;\n    }\n    if (true) {\n        if (!isSameVnode(n1, n2)) {\n            throw new Error('Expected these VNodes to be the same: ' +\n                JSON.stringify({ sel: n1.sel, key: n1.key }) +\n                ', ' +\n                JSON.stringify({ sel: n2.sel, key: n2.key }));\n        }\n    }\n    switch (n2.type) {\n        case 0 /* VNodeType.Text */:\n            // VText has no special capability, fallback to the owner's renderer\n            patchText(n1, n2, renderer);\n            break;\n        case 1 /* VNodeType.Comment */:\n            // VComment has no special capability, fallback to the owner's renderer\n            patchComment(n1, n2, renderer);\n            break;\n        case 4 /* VNodeType.Static */:\n            n2.elm = n1.elm;\n            break;\n        case 5 /* VNodeType.Fragment */:\n            patchFragment(n1, n2, parent, renderer);\n            break;\n        case 2 /* VNodeType.Element */:\n            patchElement(n1, n2, (_a = n2.data.renderer) !== null && _a !== void 0 ? _a : renderer);\n            break;\n        case 3 /* VNodeType.CustomElement */:\n            patchCustomElement(n1, n2, parent, (_b = n2.data.renderer) !== null && _b !== void 0 ? _b : renderer);\n            break;\n    }\n}\nfunction mount(node, parent, renderer, anchor) {\n    var _a, _b;\n    switch (node.type) {\n        case 0 /* VNodeType.Text */:\n            // VText has no special capability, fallback to the owner's renderer\n            mountText(node, parent, anchor, renderer);\n            break;\n        case 1 /* VNodeType.Comment */:\n            // VComment has no special capability, fallback to the owner's renderer\n            mountComment(node, parent, anchor, renderer);\n            break;\n        case 4 /* VNodeType.Static */:\n            // VStatic cannot have a custom renderer associated to them, using owner's renderer\n            mountStatic(node, parent, anchor, renderer);\n            break;\n        case 5 /* VNodeType.Fragment */:\n            mountFragment(node, parent, anchor, renderer);\n            break;\n        case 2 /* VNodeType.Element */:\n            // If the vnode data has a renderer override use it, else fallback to owner's renderer\n            mountElement(node, parent, anchor, (_a = node.data.renderer) !== null && _a !== void 0 ? _a : renderer);\n            break;\n        case 3 /* VNodeType.CustomElement */:\n            // If the vnode data has a renderer override use it, else fallback to owner's renderer\n            mountCustomElement(node, parent, anchor, (_b = node.data.renderer) !== null && _b !== void 0 ? _b : renderer);\n            break;\n    }\n}\nfunction patchText(n1, n2, renderer) {\n    n2.elm = n1.elm;\n    if (n2.text !== n1.text) {\n        updateTextContent(n2, renderer);\n    }\n}\nfunction mountText(vnode, parent, anchor, renderer) {\n    const { owner } = vnode;\n    const { createText } = renderer;\n    const textNode = (vnode.elm = createText(vnode.text));\n    linkNodeToShadow(textNode, owner, renderer);\n    insertNode(textNode, parent, anchor, renderer);\n}\nfunction patchComment(n1, n2, renderer) {\n    n2.elm = n1.elm;\n    // FIXME: Comment nodes should be static, we shouldn't need to diff them together. However\n    // it is the case today.\n    if (n2.text !== n1.text) {\n        updateTextContent(n2, renderer);\n    }\n}\nfunction mountComment(vnode, parent, anchor, renderer) {\n    const { owner } = vnode;\n    const { createComment } = renderer;\n    const commentNode = (vnode.elm = createComment(vnode.text));\n    linkNodeToShadow(commentNode, owner, renderer);\n    insertNode(commentNode, parent, anchor, renderer);\n}\nfunction mountFragment(vnode, parent, anchor, renderer) {\n    const { children } = vnode;\n    mountVNodes(children, parent, renderer, anchor);\n    // children of a fragment will always have at least the two delimiters.\n    vnode.elm = children[children.length - 1].elm;\n}\nfunction patchFragment(n1, n2, parent, renderer) {\n    const { children, stable } = n2;\n    if (stable) {\n        updateStaticChildren(n1.children, children, parent, renderer);\n    }\n    else {\n        updateDynamicChildren(n1.children, children, parent, renderer);\n    }\n    // Note: not reusing n1.elm, because during patching, it may be patched with another text node.\n    n2.elm = children[children.length - 1].elm;\n}\nfunction mountElement(vnode, parent, anchor, renderer) {\n    const { sel, owner, data: { svg }, } = vnode;\n    const { createElement } = renderer;\n    const namespace = isTrue(svg) ? SVG_NAMESPACE : undefined;\n    const elm = (vnode.elm = createElement(sel, namespace));\n    linkNodeToShadow(elm, owner, renderer);\n    applyStyleScoping(elm, owner, renderer);\n    applyDomManual(elm, vnode);\n    applyElementRestrictions(elm, vnode);\n    patchElementPropsAndAttrs$1(null, vnode, renderer);\n    insertNode(elm, parent, anchor, renderer);\n    mountVNodes(vnode.children, elm, renderer, null);\n}\nfunction patchElement(n1, n2, renderer) {\n    const elm = (n2.elm = n1.elm);\n    patchElementPropsAndAttrs$1(n1, n2, renderer);\n    patchChildren(n1.children, n2.children, elm, renderer);\n}\nfunction mountStatic(vnode, parent, anchor, renderer) {\n    const { owner } = vnode;\n    const { cloneNode, isSyntheticShadowDefined } = renderer;\n    const elm = (vnode.elm = cloneNode(vnode.fragment, true));\n    linkNodeToShadow(elm, owner, renderer);\n    applyElementRestrictions(elm, vnode);\n    // Marks this node as Static to propagate the shadow resolver. must happen after elm is assigned to the proper shadow\n    const { renderMode, shadowMode } = owner;\n    if (isSyntheticShadowDefined) {\n        if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {\n            elm[KEY__SHADOW_STATIC] = true;\n        }\n    }\n    insertNode(elm, parent, anchor, renderer);\n}\nfunction mountCustomElement(vnode, parent, anchor, renderer) {\n    const { sel, owner } = vnode;\n    const { createCustomElement } = renderer;\n    /**\n     * Note: if the upgradable constructor does not expect, or throw when we new it\n     * with a callback as the first argument, we could implement a more advanced\n     * mechanism that only passes that argument if the constructor is known to be\n     * an upgradable custom element.\n     */\n    let vm;\n    const upgradeCallback = (elm) => {\n        // the custom element from the registry is expecting an upgrade callback\n        vm = createViewModelHook(elm, vnode, renderer);\n    };\n    let connectedCallback;\n    let disconnectedCallback;\n    if (lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {\n        connectedCallback = (elm) => {\n            connectRootElement(elm);\n        };\n        disconnectedCallback = (elm) => {\n            disconnectRootElement(elm);\n        };\n    }\n    // Should never get a tag with upper case letter at this point; the compiler\n    // should produce only tags with lowercase letters. However, the Java\n    // compiler may generate tagnames with uppercase letters so - for backwards\n    // compatibility, we lower case the tagname here.\n    const normalizedTagname = sel.toLowerCase();\n    const elm = createCustomElement(normalizedTagname, upgradeCallback, connectedCallback, disconnectedCallback);\n    vnode.elm = elm;\n    vnode.vm = vm;\n    linkNodeToShadow(elm, owner, renderer);\n    applyStyleScoping(elm, owner, renderer);\n    if (vm) {\n        allocateChildren(vnode, vm);\n    }\n    patchElementPropsAndAttrs$1(null, vnode, renderer);\n    insertNode(elm, parent, anchor, renderer);\n    if (vm) {\n        {\n            if (!lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {\n                if (true) {\n                    // With synthetic lifecycle callbacks, it's possible for elements to be removed without the engine\n                    // noticing it (e.g. `appendChild` the same host element twice). This test ensures we don't regress.\n                    assert.isTrue(vm.state === 0 /* VMState.created */, `${vm} cannot be recycled.`);\n                }\n                runConnectedCallback(vm);\n            }\n        }\n    }\n    mountVNodes(vnode.children, elm, renderer, null);\n    if (vm) {\n        appendVM(vm);\n    }\n}\nfunction patchCustomElement(n1, n2, parent, renderer) {\n    if (n1.ctor !== n2.ctor) {\n        // If the constructor, unmount the current component and mount a new one using the new\n        // constructor.\n        const anchor = renderer.nextSibling(n1.elm);\n        unmount(n1, parent, renderer, true);\n        mountCustomElement(n2, parent, anchor, renderer);\n    }\n    else {\n        // Otherwise patch the existing component with new props/attrs/etc.\n        const elm = (n2.elm = n1.elm);\n        const vm = (n2.vm = n1.vm);\n        patchElementPropsAndAttrs$1(n1, n2, renderer);\n        if (!isUndefined$1(vm)) {\n            // in fallback mode, the allocation will always set children to\n            // empty and delegate the real allocation to the slot elements\n            allocateChildren(n2, vm);\n            // Solves an edge case with slotted VFragments in native shadow mode.\n            //\n            // During allocation, in native shadow, slotted VFragment nodes are flattened and their text delimiters are removed\n            // to avoid interfering with native slot behavior. When this happens, if any of the fragments\n            // were not stable, the children must go through the dynamic diffing algo.\n            //\n            // If the new children (n2.children) contain no VFragments, but the previous children (n1.children) were dynamic,\n            // the new nodes must be marked dynamic so that all nodes are properly updated. The only indicator that the new\n            // nodes need to be dynamic comes from the previous children, so we check that to determine whether we need to\n            // mark the new children dynamic.\n            //\n            // Example:\n            // n1.children: [div, VFragment('', div, null, ''), div] => [div, div, null, div]; // marked dynamic\n            // n2.children: [div, null, div] => [div, null, div] // marked ???\n            const { shadowMode, renderMode } = vm;\n            if (shadowMode == 0 /* ShadowMode.Native */ &&\n                renderMode !== 0 /* RenderMode.Light */ &&\n                hasDynamicChildren(n1.children)) {\n                // No-op if children has already been marked dynamic by 'allocateChildren()'.\n                markAsDynamicChildren(n2.children);\n            }\n        }\n        // in fallback mode, the children will be always empty, so, nothing\n        // will happen, but in native, it does allocate the light dom\n        patchChildren(n1.children, n2.children, elm, renderer);\n        if (!isUndefined$1(vm)) {\n            // this will probably update the shadowRoot, but only if the vm is in a dirty state\n            // this is important to preserve the top to bottom synchronous rendering phase.\n            rerenderVM(vm);\n        }\n    }\n}\nfunction mountVNodes(vnodes, parent, renderer, anchor, start = 0, end = vnodes.length) {\n    for (; start < end; ++start) {\n        const vnode = vnodes[start];\n        if (isVNode(vnode)) {\n            mount(vnode, parent, renderer, anchor);\n        }\n    }\n}\nfunction unmount(vnode, parent, renderer, doRemove = false) {\n    const { type, elm, sel } = vnode;\n    // When unmounting a VNode subtree not all the elements have to removed from the DOM. The\n    // subtree root, is the only element worth unmounting from the subtree.\n    if (doRemove) {\n        if (type === 5 /* VNodeType.Fragment */) {\n            unmountVNodes(vnode.children, parent, renderer, doRemove);\n        }\n        else {\n            // The vnode might or might not have a data.renderer associated to it\n            // but the removal used here is from the owner instead.\n            removeNode(elm, parent, renderer);\n        }\n    }\n    switch (type) {\n        case 2 /* VNodeType.Element */: {\n            // Slot content is removed to trigger slotchange event when removing slot.\n            // Only required for synthetic shadow.\n            const shouldRemoveChildren = sel === 'slot' && vnode.owner.shadowMode === 1 /* ShadowMode.Synthetic */;\n            unmountVNodes(vnode.children, elm, renderer, shouldRemoveChildren);\n            break;\n        }\n        case 3 /* VNodeType.CustomElement */: {\n            const { vm } = vnode;\n            // No need to unmount the children here, `removeVM` will take care of removing the\n            // children.\n            if (!isUndefined$1(vm)) {\n                removeVM(vm);\n            }\n        }\n    }\n}\nfunction unmountVNodes(vnodes, parent, renderer, doRemove = false, start = 0, end = vnodes.length) {\n    for (; start < end; ++start) {\n        const ch = vnodes[start];\n        if (isVNode(ch)) {\n            unmount(ch, parent, renderer, doRemove);\n        }\n    }\n}\nfunction isVNode(vnode) {\n    return vnode != null;\n}\nfunction linkNodeToShadow(elm, owner, renderer) {\n    const { renderRoot, renderMode, shadowMode } = owner;\n    const { isSyntheticShadowDefined } = renderer;\n    // TODO [#1164]: this should eventually be done by the polyfill directly\n    if (isSyntheticShadowDefined) {\n        if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {\n            elm[KEY__SHADOW_RESOLVER] = renderRoot[KEY__SHADOW_RESOLVER];\n        }\n    }\n}\nfunction updateTextContent(vnode, renderer) {\n    const { elm, text } = vnode;\n    const { setText } = renderer;\n    if (true) {\n        unlockDomMutation();\n    }\n    setText(elm, text);\n    if (true) {\n        lockDomMutation();\n    }\n}\nfunction insertNode(node, parent, anchor, renderer) {\n    if (true) {\n        unlockDomMutation();\n    }\n    renderer.insert(node, parent, anchor);\n    if (true) {\n        lockDomMutation();\n    }\n}\nfunction removeNode(node, parent, renderer) {\n    if (true) {\n        unlockDomMutation();\n    }\n    renderer.remove(node, parent);\n    if (true) {\n        lockDomMutation();\n    }\n}\nfunction patchElementPropsAndAttrs$1(oldVnode, vnode, renderer) {\n    if (isNull(oldVnode)) {\n        applyEventListeners(vnode, renderer);\n        applyStaticClassAttribute(vnode, renderer);\n        applyStaticStyleAttribute(vnode, renderer);\n    }\n    // Attrs need to be applied to element before props IE11 will wipe out value on radio inputs if\n    // value is set before type=radio.\n    patchClassAttribute(oldVnode, vnode, renderer);\n    patchStyleAttribute(oldVnode, vnode, renderer);\n    if (vnode.data.external) {\n        patchAttrUnlessProp(oldVnode, vnode, renderer);\n    }\n    else {\n        patchAttributes(oldVnode, vnode, renderer);\n    }\n    patchProps(oldVnode, vnode, renderer);\n}\nfunction applyStyleScoping(elm, owner, renderer) {\n    // Set the class name for `*.scoped.css` style scoping.\n    const scopeToken = getScopeTokenClass(owner);\n    if (!isNull(scopeToken)) {\n        const { getClassList } = renderer;\n        // TODO [#2762]: this dot notation with add is probably problematic\n        // probably we should have a renderer api for just the add operation\n        getClassList(elm).add(scopeToken);\n    }\n    // Set property element for synthetic shadow DOM style scoping.\n    const { stylesheetToken: syntheticToken } = owner.context;\n    if (owner.shadowMode === 1 /* ShadowMode.Synthetic */ && !isUndefined$1(syntheticToken)) {\n        elm.$shadowToken$ = syntheticToken;\n    }\n}\nfunction applyDomManual(elm, vnode) {\n    var _a;\n    const { owner, data: { context }, } = vnode;\n    if (owner.shadowMode === 1 /* ShadowMode.Synthetic */ && ((_a = context === null || context === void 0 ? void 0 : context.lwc) === null || _a === void 0 ? void 0 : _a.dom) === \"manual\" /* LwcDomMode.Manual */) {\n        elm.$domManual$ = true;\n    }\n}\nfunction applyElementRestrictions(elm, vnode) {\n    var _a, _b;\n    if (true) {\n        const isSynthetic = vnode.owner.shadowMode === 1 /* ShadowMode.Synthetic */;\n        const isPortal = vnode.type === 2 /* VNodeType.Element */ && ((_b = (_a = vnode.data.context) === null || _a === void 0 ? void 0 : _a.lwc) === null || _b === void 0 ? void 0 : _b.dom) === \"manual\" /* LwcDomMode.Manual */;\n        const isLight = vnode.owner.renderMode === 0 /* RenderMode.Light */;\n        patchElementWithRestrictions(elm, {\n            isPortal,\n            isLight,\n            isSynthetic,\n        });\n    }\n}\nfunction allocateChildren(vnode, vm) {\n    // A component with slots will re-render because:\n    // 1- There is a change of the internal state.\n    // 2- There is a change on the external api (ex: slots)\n    //\n    // In case #1, the vnodes in the cmpSlots will be reused since they didn't changed. This routine emptied the\n    // slotted children when those VCustomElement were rendered and therefore in subsequent calls to allocate children\n    // in a reused VCustomElement, there won't be any slotted children.\n    // For those cases, we will use the reference for allocated children stored when rendering the fresh VCustomElement.\n    //\n    // In case #2, we will always get a fresh VCustomElement.\n    const children = vnode.aChildren || vnode.children;\n    const { renderMode, shadowMode } = vm;\n    if (true) {\n        // If any of the children being allocated is a scoped slot fragment, make sure the receiving\n        // component is a light DOM component. This is mainly to validate light dom parent running\n        // in native shadow mode.\n        if (renderMode !== 0 /* RenderMode.Light */ &&\n            ArraySome.call(children, (child) => !isNull(child) && isVScopedSlotFragment(child))) {\n            logError(`Invalid usage of 'lwc:slot-data' on ${getComponentTag(vm)} tag. Scoped slot content can only be passed to a light dom child.`);\n        }\n    }\n    // If any of the children being allocated are VFragments, we remove the text delimiters and flatten all immediate\n    // children VFragments to avoid them interfering with default slot behavior.\n    const allocatedChildren = flattenFragmentsInChildren(children);\n    vnode.children = allocatedChildren;\n    vm.aChildren = allocatedChildren;\n    if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {\n        // slow path\n        allocateInSlot(vm, allocatedChildren, vnode.owner);\n        // save the allocated children in case this vnode is reused.\n        vnode.aChildren = allocatedChildren;\n        // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!\n        vnode.children = EmptyArray;\n    }\n}\n/**\n * Flattens the contents of all VFragments in an array of VNodes, removes the text delimiters on those VFragments, and\n * marks the resulting children array as dynamic. Uses a stack (array) to iteratively traverse the nested VFragments\n * and avoid the perf overhead of creating/destroying throwaway arrays/objects in a recursive approach.\n *\n * With the delimiters removed, the contents are marked dynamic so they are diffed correctly.\n *\n * This function is used for slotted VFragments to avoid the text delimiters interfering with slotting functionality.\n */\nfunction flattenFragmentsInChildren(children) {\n    const flattenedChildren = [];\n    // Initialize our stack with the direct children of the custom component and check whether we have a VFragment.\n    // If no VFragment is found in children, we don't need to traverse anything or mark the children dynamic and can return early.\n    const nodeStack = [];\n    let fragmentFound = false;\n    for (let i = children.length - 1; i > -1; i -= 1) {\n        const child = children[i];\n        ArrayPush$1.call(nodeStack, child);\n        fragmentFound = fragmentFound || !!(child && isVFragment(child));\n    }\n    if (!fragmentFound) {\n        return children;\n    }\n    let currentNode;\n    while (!isUndefined$1((currentNode = ArrayPop.call(nodeStack)))) {\n        if (!isNull(currentNode) && isVFragment(currentNode)) {\n            const fChildren = currentNode.children;\n            // Ignore the start and end text node delimiters\n            for (let i = fChildren.length - 2; i > 0; i -= 1) {\n                ArrayPush$1.call(nodeStack, fChildren[i]);\n            }\n        }\n        else {\n            ArrayPush$1.call(flattenedChildren, currentNode);\n        }\n    }\n    // We always mark the children as dynamic because nothing generates stable VFragments yet.\n    // If/when stable VFragments are generated by the compiler, this code should be updated to\n    // not mark dynamic if all flattened VFragments were stable.\n    markAsDynamicChildren(flattenedChildren);\n    return flattenedChildren;\n}\nfunction createViewModelHook(elm, vnode, renderer) {\n    let vm = getAssociatedVMIfPresent(elm);\n    // There is a possibility that a custom element is registered under tagName, in which case, the\n    // initialization is already carry on, and there is nothing else to do here since this hook is\n    // called right after invoking `document.createElement`.\n    if (!isUndefined$1(vm)) {\n        return vm;\n    }\n    const { sel, mode, ctor, owner } = vnode;\n    vm = createVM(elm, ctor, renderer, {\n        mode,\n        owner,\n        tagName: sel,\n    });\n    if (true) {\n        assert.isTrue(isArray$1(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n    }\n    return vm;\n}\nfunction allocateInSlot(vm, children, owner) {\n    var _a, _b;\n    const { cmpSlots: { slotAssignments: oldSlotsMapping }, } = vm;\n    const cmpSlotsMapping = create(null);\n    // Collect all slots into cmpSlotsMapping\n    for (let i = 0, len = children.length; i < len; i += 1) {\n        const vnode = children[i];\n        if (isNull(vnode)) {\n            continue;\n        }\n        let slotName = '';\n        if (isVBaseElement(vnode)) {\n            slotName = (_b = (_a = vnode.data.attrs) === null || _a === void 0 ? void 0 : _a.slot) !== null && _b !== void 0 ? _b : '';\n        }\n        else if (isVScopedSlotFragment(vnode)) {\n            slotName = vnode.slotName;\n        }\n        // Can't use toString here because Symbol(1).toString() is 'Symbol(1)'\n        // but elm.setAttribute('slot', Symbol(1)) is an error.\n        // the following line also throws same error for symbols\n        // Similar for Object.create(null)\n        const normalizedSlotName = '' + slotName;\n        const vnodes = (cmpSlotsMapping[normalizedSlotName] =\n            cmpSlotsMapping[normalizedSlotName] || []);\n        ArrayPush$1.call(vnodes, vnode);\n    }\n    vm.cmpSlots = { owner, slotAssignments: cmpSlotsMapping };\n    if (isFalse(vm.isDirty)) {\n        // We need to determine if the old allocation is really different from the new one\n        // and mark the vm as dirty\n        const oldKeys = keys(oldSlotsMapping);\n        if (oldKeys.length !== keys(cmpSlotsMapping).length) {\n            markComponentAsDirty(vm);\n            return;\n        }\n        for (let i = 0, len = oldKeys.length; i < len; i += 1) {\n            const key = oldKeys[i];\n            if (isUndefined$1(cmpSlotsMapping[key]) ||\n                oldSlotsMapping[key].length !== cmpSlotsMapping[key].length) {\n                markComponentAsDirty(vm);\n                return;\n            }\n            const oldVNodes = oldSlotsMapping[key];\n            const vnodes = cmpSlotsMapping[key];\n            for (let j = 0, a = cmpSlotsMapping[key].length; j < a; j += 1) {\n                if (oldVNodes[j] !== vnodes[j]) {\n                    markComponentAsDirty(vm);\n                    return;\n                }\n            }\n        }\n    }\n}\n// Using a WeakMap instead of a WeakSet because this one works in IE11 :(\nconst DynamicChildren = new WeakMap();\n// dynamic children means it was either generated by an iteration in a template\n// or part of an unstable fragment, and will require a more complex diffing algo.\nfunction markAsDynamicChildren(children) {\n    DynamicChildren.set(children, 1);\n}\nfunction hasDynamicChildren(children) {\n    return DynamicChildren.has(children);\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    const map = {};\n    // TODO [#1637]: simplify this by assuming that all vnodes has keys\n    for (let j = beginIdx; j <= endIdx; ++j) {\n        const ch = children[j];\n        if (isVNode(ch)) {\n            const { key } = ch;\n            if (key !== undefined) {\n                map[key] = j;\n            }\n        }\n    }\n    return map;\n}\nfunction updateDynamicChildren(oldCh, newCh, parent, renderer) {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    const newChEnd = newCh.length - 1;\n    let newEndIdx = newChEnd;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let oldKeyToIdx;\n    let idxInOld;\n    let elmToMove;\n    let before;\n    let clonedOldCh = false;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (!isVNode(oldStartVnode)) {\n            oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n        }\n        else if (!isVNode(oldEndVnode)) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (!isVNode(newStartVnode)) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (!isVNode(newEndVnode)) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode, parent, renderer);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode, parent, renderer);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            patch(oldStartVnode, newEndVnode, parent, renderer);\n            insertNode(oldStartVnode.elm, parent, renderer.nextSibling(oldEndVnode.elm), renderer);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            patch(oldEndVnode, newStartVnode, parent, renderer);\n            insertNode(newStartVnode.elm, parent, oldStartVnode.elm, renderer);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            if (oldKeyToIdx === undefined) {\n                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n            }\n            idxInOld = oldKeyToIdx[newStartVnode.key];\n            if (isUndefined$1(idxInOld)) {\n                // New element\n                mount(newStartVnode, parent, renderer, oldStartVnode.elm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                elmToMove = oldCh[idxInOld];\n                if (isVNode(elmToMove)) {\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        // New element\n                        mount(newStartVnode, parent, renderer, oldStartVnode.elm);\n                    }\n                    else {\n                        patch(elmToMove, newStartVnode, parent, renderer);\n                        // Delete the old child, but copy the array since it is read-only.\n                        // The `oldCh` will be GC'ed after `updateDynamicChildren` is complete,\n                        // so we only care about the `oldCh` object inside this function.\n                        // To avoid cloning over and over again, we check `clonedOldCh`\n                        // and only clone once.\n                        if (!clonedOldCh) {\n                            clonedOldCh = true;\n                            oldCh = [...oldCh];\n                        }\n                        // We've already cloned at least once, so it's no longer read-only\n                        oldCh[idxInOld] = undefined;\n                        insertNode(elmToMove.elm, parent, oldStartVnode.elm, renderer);\n                    }\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n        }\n    }\n    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n        if (oldStartIdx > oldEndIdx) {\n            // There's some cases in which the sub array of vnodes to be inserted is followed by null(s) and an\n            // already processed vnode, in such cases the vnodes to be inserted should be before that processed vnode.\n            let i = newEndIdx;\n            let n;\n            do {\n                n = newCh[++i];\n            } while (!isVNode(n) && i < newChEnd);\n            before = isVNode(n) ? n.elm : null;\n            mountVNodes(newCh, parent, renderer, before, newStartIdx, newEndIdx + 1);\n        }\n        else {\n            unmountVNodes(oldCh, parent, renderer, true, oldStartIdx, oldEndIdx + 1);\n        }\n    }\n}\nfunction updateStaticChildren(c1, c2, parent, renderer) {\n    const c1Length = c1.length;\n    const c2Length = c2.length;\n    if (c1Length === 0) {\n        // the old list is empty, we can directly insert anything new\n        mountVNodes(c2, parent, renderer, null);\n        return;\n    }\n    if (c2Length === 0) {\n        // the old list is nonempty and the new list is empty so we can directly remove all old nodes\n        // this is the case in which the dynamic children of an if-directive should be removed\n        unmountVNodes(c1, parent, renderer, true);\n        return;\n    }\n    // if the old list is not empty, the new list MUST have the same\n    // amount of nodes, that's why we call this static children\n    let anchor = null;\n    for (let i = c2Length - 1; i >= 0; i -= 1) {\n        const n1 = c1[i];\n        const n2 = c2[i];\n        if (n2 !== n1) {\n            if (isVNode(n1)) {\n                if (isVNode(n2)) {\n                    // both vnodes are equivalent, and we just need to patch them\n                    patch(n1, n2, parent, renderer);\n                    anchor = n2.elm;\n                }\n                else {\n                    // removing the old vnode since the new one is null\n                    unmount(n1, parent, renderer, true);\n                }\n            }\n            else if (isVNode(n2)) {\n                mount(n2, parent, renderer, anchor);\n                anchor = n2.elm;\n            }\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst SymbolIterator = Symbol.iterator;\nfunction addVNodeToChildLWC(vnode) {\n    ArrayPush$1.call(getVMBeingRendered().velements, vnode);\n}\n// [s]coped [s]lot [f]actory\nfunction ssf(slotName, factory) {\n    return {\n        type: 6 /* VNodeType.ScopedSlotFragment */,\n        factory,\n        owner: getVMBeingRendered(),\n        elm: undefined,\n        sel: undefined,\n        key: undefined,\n        slotName,\n    };\n}\n// [st]atic node\nfunction st(fragment, key) {\n    return {\n        type: 4 /* VNodeType.Static */,\n        sel: undefined,\n        key,\n        elm: undefined,\n        fragment,\n        owner: getVMBeingRendered(),\n    };\n}\n// [fr]agment node\nfunction fr(key, children, stable) {\n    return {\n        type: 5 /* VNodeType.Fragment */,\n        sel: undefined,\n        key,\n        elm: undefined,\n        children: [t(''), ...children, t('')],\n        stable,\n        owner: getVMBeingRendered(),\n    };\n}\n// [h]tml node\nfunction h(sel, data, children = EmptyArray) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (true) {\n        assert.isTrue(isString(sel), `h() 1st argument sel must be a string.`);\n        assert.isTrue(isObject(data), `h() 2nd argument data must be an object.`);\n        assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);\n        assert.isTrue('key' in data, ` <${sel}> \"key\" attribute is invalid or missing for ${vmBeingRendered}. Key inside iterator is either undefined or null.`);\n        // checking reserved internal data properties\n        assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n        assert.isFalse(data.styleDecls && data.style, `vnode.data.styleDecls and vnode.data.style ambiguous declaration.`);\n        if (data.style && !isString(data.style)) {\n            logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);\n        }\n        forEach.call(children, (childVnode) => {\n            if (childVnode != null) {\n                assert.isTrue('type' in childVnode &&\n                    'sel' in childVnode &&\n                    'elm' in childVnode &&\n                    'key' in childVnode, `${childVnode} is not a vnode.`);\n            }\n        });\n    }\n    const { key, ref } = data;\n    const vnode = {\n        type: 2 /* VNodeType.Element */,\n        sel,\n        data,\n        children,\n        elm: undefined,\n        key,\n        owner: vmBeingRendered,\n    };\n    if (!isUndefined$1(ref)) {\n        setRefVNode(vmBeingRendered, ref, vnode);\n    }\n    return vnode;\n}\n// [t]ab[i]ndex function\nfunction ti(value) {\n    // if value is greater than 0, we normalize to 0\n    // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through\n    // If value is less than -1, we don't care\n    const shouldNormalize = value > 0 && !(isTrue(value) || isFalse(value));\n    if (true) {\n        const vmBeingRendered = getVMBeingRendered();\n        if (shouldNormalize) {\n            logError(`Invalid tabindex value \\`${toString$1(value)}\\` in template for ${vmBeingRendered}. This attribute must be set to 0 or -1.`, vmBeingRendered);\n        }\n    }\n    return shouldNormalize ? 0 : value;\n}\n// [s]lot element node\nfunction s(slotName, data, children, slotset) {\n    if (true) {\n        assert.isTrue(isString(slotName), `s() 1st argument slotName must be a string.`);\n        assert.isTrue(isObject(data), `s() 2nd argument data must be an object.`);\n        assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);\n    }\n    if (!isUndefined$1(slotset) &&\n        !isUndefined$1(slotset.slotAssignments) &&\n        !isUndefined$1(slotset.slotAssignments[slotName]) &&\n        slotset.slotAssignments[slotName].length !== 0) {\n        const newChildren = [];\n        const slotAssignments = slotset.slotAssignments[slotName];\n        for (let i = 0; i < slotAssignments.length; i++) {\n            const vnode = slotAssignments[i];\n            if (!isNull(vnode)) {\n                const assignedNodeIsScopedSlot = isVScopedSlotFragment(vnode);\n                // The only sniff test for a scoped <slot> element is the presence of `slotData`\n                const isScopedSlotElement = !isUndefined$1(data.slotData);\n                // Check if slot types of parent and child are matching\n                if (assignedNodeIsScopedSlot !== isScopedSlotElement) {\n                    if (true) {\n                        logError(`Mismatched slot types for ${slotName === '' ? '(default)' : slotName} slot. Both parent and child component must use standard type or scoped type for a given slot.`, slotset.owner);\n                    }\n                    // Ignore slot content from parent\n                    continue;\n                }\n                // If the passed slot content is factory, evaluate it and add the produced vnodes\n                if (assignedNodeIsScopedSlot) {\n                    const vmBeingRenderedInception = getVMBeingRendered();\n                    // Evaluate in the scope of the slot content's owner\n                    // if a slotset is provided, there will always be an owner. The only case where owner is\n                    // undefined is for root components, but root components cannot accept slotted content\n                    setVMBeingRendered(slotset.owner);\n                    try {\n                        ArrayPush$1.call(newChildren, vnode.factory(data.slotData, data.key));\n                    }\n                    finally {\n                        setVMBeingRendered(vmBeingRenderedInception);\n                    }\n                }\n                else {\n                    // If the slot content is standard type, the content is static, no additional\n                    // processing needed on the vnode\n                    ArrayPush$1.call(newChildren, vnode);\n                }\n            }\n        }\n        children = newChildren;\n    }\n    const vmBeingRendered = getVMBeingRendered();\n    const { renderMode, shadowMode } = vmBeingRendered;\n    if (renderMode === 0 /* RenderMode.Light */) {\n        sc(children);\n        return children;\n    }\n    if (shadowMode === 1 /* ShadowMode.Synthetic */) {\n        // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n        sc(children);\n    }\n    return h('slot', data, children);\n}\n// [c]ustom element node\nfunction c(sel, Ctor, data, children = EmptyArray) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (true) {\n        assert.isTrue(isString(sel), `c() 1st argument sel must be a string.`);\n        assert.isTrue(isFunction$1(Ctor), `c() 2nd argument Ctor must be a function.`);\n        assert.isTrue(isObject(data), `c() 3nd argument data must be an object.`);\n        assert.isTrue(arguments.length === 3 || isArray$1(children), `c() 4nd argument data must be an array.`);\n        // checking reserved internal data properties\n        assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n        assert.isFalse(data.styleDecls && data.style, `vnode.data.styleDecls and vnode.data.style ambiguous declaration.`);\n        if (data.style && !isString(data.style)) {\n            logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);\n        }\n        if (arguments.length === 4) {\n            forEach.call(children, (childVnode) => {\n                if (childVnode != null) {\n                    assert.isTrue('type' in childVnode &&\n                        'sel' in childVnode &&\n                        'elm' in childVnode &&\n                        'key' in childVnode, `${childVnode} is not a vnode.`);\n                }\n            });\n        }\n    }\n    const { key, ref } = data;\n    let elm, aChildren, vm;\n    const vnode = {\n        type: 3 /* VNodeType.CustomElement */,\n        sel,\n        data,\n        children,\n        elm,\n        key,\n        ctor: Ctor,\n        owner: vmBeingRendered,\n        mode: 'open',\n        aChildren,\n        vm,\n    };\n    addVNodeToChildLWC(vnode);\n    if (!isUndefined$1(ref)) {\n        setRefVNode(vmBeingRendered, ref, vnode);\n    }\n    return vnode;\n}\n// [i]terable node\nfunction i(iterable, factory) {\n    const list = [];\n    // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n    sc(list);\n    const vmBeingRendered = getVMBeingRendered();\n    if (isUndefined$1(iterable) || iterable === null) {\n        if (true) {\n            logError(`Invalid template iteration for value \"${toString$1(iterable)}\" in ${vmBeingRendered}. It must be an Array or an iterable Object.`, vmBeingRendered);\n        }\n        return list;\n    }\n    if (true) {\n        assert.isFalse(isUndefined$1(iterable[SymbolIterator]), `Invalid template iteration for value \\`${toString$1(iterable)}\\` in ${vmBeingRendered}. It must be an array-like object and not \\`null\\` nor \\`undefined\\`.`);\n    }\n    const iterator = iterable[SymbolIterator]();\n    if (true) {\n        assert.isTrue(iterator && isFunction$1(iterator.next), `Invalid iterator function for \"${toString$1(iterable)}\" in ${vmBeingRendered}.`);\n    }\n    let next = iterator.next();\n    let j = 0;\n    let { value, done: last } = next;\n    let keyMap;\n    let iterationError;\n    if (true) {\n        keyMap = create(null);\n    }\n    while (last === false) {\n        // implementing a look-back-approach because we need to know if the element is the last\n        next = iterator.next();\n        last = next.done;\n        // template factory logic based on the previous collected value\n        const vnode = factory(value, j, j === 0, last === true);\n        if (isArray$1(vnode)) {\n            ArrayPush$1.apply(list, vnode);\n        }\n        else {\n            ArrayPush$1.call(list, vnode);\n        }\n        if (true) {\n            const vnodes = isArray$1(vnode) ? vnode : [vnode];\n            forEach.call(vnodes, (childVnode) => {\n                if (!isNull(childVnode) && isObject(childVnode) && !isUndefined$1(childVnode.sel)) {\n                    const { key } = childVnode;\n                    if (isString(key) || isNumber(key)) {\n                        if (keyMap[key] === 1 && isUndefined$1(iterationError)) {\n                            iterationError = `Duplicated \"key\" attribute value for \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. A key with value \"${childVnode.key}\" appears more than once in the iteration. Key values must be unique numbers or strings.`;\n                        }\n                        keyMap[key] = 1;\n                    }\n                    else if (isUndefined$1(iterationError)) {\n                        iterationError = `Invalid \"key\" attribute value in \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. Set a unique \"key\" value on all iterated child elements.`;\n                    }\n                }\n            });\n        }\n        // preparing next value\n        j += 1;\n        value = next.value;\n    }\n    if (true) {\n        if (!isUndefined$1(iterationError)) {\n            logError(iterationError, vmBeingRendered);\n        }\n    }\n    return list;\n}\n/**\n * [f]lattening\n */\nfunction f(items) {\n    if (true) {\n        assert.isTrue(isArray$1(items), 'flattening api can only work with arrays.');\n    }\n    const len = items.length;\n    const flattened = [];\n    // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n    sc(flattened);\n    for (let j = 0; j < len; j += 1) {\n        const item = items[j];\n        if (isArray$1(item)) {\n            ArrayPush$1.apply(flattened, item);\n        }\n        else {\n            ArrayPush$1.call(flattened, item);\n        }\n    }\n    return flattened;\n}\n// [t]ext node\nfunction t(text) {\n    let sel, key, elm;\n    return {\n        type: 0 /* VNodeType.Text */,\n        sel,\n        text,\n        elm,\n        key,\n        owner: getVMBeingRendered(),\n    };\n}\n// [co]mment node\nfunction co(text) {\n    let sel, elm;\n    return {\n        type: 1 /* VNodeType.Comment */,\n        sel,\n        text,\n        elm,\n        key: 'c',\n        owner: getVMBeingRendered(),\n    };\n}\n// [d]ynamic text\nfunction d(value) {\n    return value == null ? '' : String(value);\n}\n// [b]ind function\nfunction b(fn) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (isNull(vmBeingRendered)) {\n        throw new Error();\n    }\n    const vm = vmBeingRendered;\n    return function (event) {\n        invokeEventListener(vm, fn, vm.component, event);\n    };\n}\n// [k]ey function\nfunction k(compilerKey, obj) {\n    switch (typeof obj) {\n        case 'number':\n        case 'string':\n            return compilerKey + ':' + obj;\n        case 'object':\n            if (true) {\n                assert.fail(`Invalid key value \"${obj}\" in ${getVMBeingRendered()}. Key must be a string or number.`);\n            }\n    }\n}\n// [g]lobal [id] function\nfunction gid(id) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (isUndefined$1(id) || id === '') {\n        if (true) {\n            logError(`Invalid id value \"${id}\". The id attribute must contain a non-empty string.`, vmBeingRendered);\n        }\n        return id;\n    }\n    // We remove attributes when they are assigned a value of null\n    if (isNull(id)) {\n        return null;\n    }\n    const { idx, shadowMode } = vmBeingRendered;\n    if (shadowMode === 1 /* ShadowMode.Synthetic */) {\n        return StringReplace.call(id, /\\S+/g, (id) => `${id}-${idx}`);\n    }\n    return id;\n}\n// [f]ragment [id] function\nfunction fid(url) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (isUndefined$1(url) || url === '') {\n        if (true) {\n            if (isUndefined$1(url)) {\n                logError(`Undefined url value for \"href\" or \"xlink:href\" attribute. Expected a non-empty string.`, vmBeingRendered);\n            }\n        }\n        return url;\n    }\n    // We remove attributes when they are assigned a value of null\n    if (isNull(url)) {\n        return null;\n    }\n    const { idx, shadowMode } = vmBeingRendered;\n    // Apply transformation only for fragment-only-urls, and only in shadow DOM\n    if (shadowMode === 1 /* ShadowMode.Synthetic */ && /^#/.test(url)) {\n        return `${url}-${idx}`;\n    }\n    return url;\n}\n/**\n * create a dynamic component via `<x-foo lwc:dynamic={Ctor}>`\n */\nfunction dc(sel, Ctor, data, children = EmptyArray) {\n    if (true) {\n        assert.isTrue(isString(sel), `dc() 1st argument sel must be a string.`);\n        assert.isTrue(isObject(data), `dc() 3nd argument data must be an object.`);\n        assert.isTrue(arguments.length === 3 || isArray$1(children), `dc() 4nd argument data must be an array.`);\n    }\n    // null or undefined values should produce a null value in the VNodes\n    if (Ctor == null) {\n        return null;\n    }\n    if (!isComponentConstructor(Ctor)) {\n        throw new Error(`Invalid LWC Constructor ${toString$1(Ctor)} for custom element <${sel}>.`);\n    }\n    return c(sel, Ctor, data, children);\n}\n/**\n * slow children collection marking mechanism. this API allows the compiler to signal\n * to the engine that a particular collection of children must be diffed using the slow\n * algo based on keys due to the nature of the list. E.g.:\n *\n *   - slot element's children: the content of the slot has to be dynamic when in synthetic\n *                              shadow mode because the `vnode.children` might be the slotted\n *                              content vs default content, in which case the size and the\n *                              keys are not matching.\n *   - children that contain dynamic components\n *   - children that are produced by iteration\n *\n */\nfunction sc(vnodes) {\n    if (true) {\n        assert.isTrue(isArray$1(vnodes), 'sc() api can only work with arrays.');\n    }\n    // We have to mark the vnodes collection as dynamic so we can later on\n    // choose to use the snabbdom virtual dom diffing algo instead of our\n    // static dummy algo.\n    markAsDynamicChildren(vnodes);\n    return vnodes;\n}\n/**\n * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar\n * libraries to sanitize HTML content. This hook process the content passed via the template to\n * lwc:inner-html directive.\n * It is meant to be overridden with setSanitizeHtmlContentHook, it throws an error by default.\n */\nlet sanitizeHtmlContentHook = () => {\n    // locker-service patches this function during runtime to sanitize HTML content.\n    throw new Error('sanitizeHtmlContent hook must be implemented.');\n};\n/**\n * Sets the sanitizeHtmlContentHook.\n */\nfunction setSanitizeHtmlContentHook(newHookImpl) {\n    sanitizeHtmlContentHook = newHookImpl;\n}\n// [s]anitize [h]tml [c]ontent\nfunction shc(content) {\n    return sanitizeHtmlContentHook(content);\n}\nconst api = freeze({\n    s,\n    h,\n    c,\n    i,\n    f,\n    t,\n    d,\n    b,\n    k,\n    co,\n    dc,\n    fr,\n    ti,\n    st,\n    gid,\n    fid,\n    shc,\n    ssf,\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst operationIdNameMapping = [\n    'constructor',\n    'render',\n    'patch',\n    'connectedCallback',\n    'renderedCallback',\n    'disconnectedCallback',\n    'errorCallback',\n    'lwc-hydrate',\n    'lwc-rehydrate',\n];\n// Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.\n// JSDom (used in Jest) for example doesn't implement the UserTiming APIs.\nconst isUserTimingSupported = typeof performance !== 'undefined' &&\n    typeof performance.mark === 'function' &&\n    typeof performance.clearMarks === 'function' &&\n    typeof performance.measure === 'function' &&\n    typeof performance.clearMeasures === 'function';\nconst start = !isUserTimingSupported\n    ? noop\n    : (markName) => {\n        performance.mark(markName);\n    };\nconst end = !isUserTimingSupported\n    ? noop\n    : (measureName, markName) => {\n        performance.measure(measureName, markName);\n        // Clear the created marks and measure to avoid filling the performance entries buffer.\n        // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.\n        performance.clearMarks(markName);\n        performance.clearMeasures(measureName);\n    };\nfunction getOperationName(opId) {\n    return operationIdNameMapping[opId];\n}\nfunction getMeasureName(opId, vm) {\n    return `${getComponentTag(vm)} - ${getOperationName(opId)}`;\n}\nfunction getMarkName(opId, vm) {\n    // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce\n    // the right measures for components that are recursive.\n    return `${getMeasureName(opId, vm)} - ${vm.idx}`;\n}\n/** Indicates if operations should be logged via the User Timing API. */\nconst isMeasureEnabled = \"development\" !== 'production';\n/** Indicates if operations should be logged by the profiler. */\nlet isProfilerEnabled = false;\n/** The currently assigned profiler dispatcher. */\nlet currentDispatcher = noop;\nconst profilerControl = {\n    enableProfiler() {\n        isProfilerEnabled = true;\n    },\n    disableProfiler() {\n        isProfilerEnabled = false;\n    },\n    attachDispatcher(dispatcher) {\n        currentDispatcher = dispatcher;\n        this.enableProfiler();\n    },\n    detachDispatcher() {\n        const dispatcher = currentDispatcher;\n        currentDispatcher = noop;\n        this.disableProfiler();\n        return dispatcher;\n    },\n};\nfunction logOperationStart(opId, vm) {\n    if (isMeasureEnabled) {\n        const markName = getMarkName(opId, vm);\n        start(markName);\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 0 /* Phase.Start */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);\n    }\n}\nfunction logOperationEnd(opId, vm) {\n    if (isMeasureEnabled) {\n        const markName = getMarkName(opId, vm);\n        const measureName = getMeasureName(opId, vm);\n        end(measureName, markName);\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 1 /* Phase.Stop */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);\n    }\n}\nfunction logGlobalOperationStart(opId, vm) {\n    if (isMeasureEnabled) {\n        const opName = getOperationName(opId);\n        const markName = isUndefined$1(vm) ? opName : getMarkName(opId, vm);\n        start(markName);\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 0 /* Phase.Start */, vm === null || vm === void 0 ? void 0 : vm.tagName, vm === null || vm === void 0 ? void 0 : vm.idx, vm === null || vm === void 0 ? void 0 : vm.renderMode, vm === null || vm === void 0 ? void 0 : vm.shadowMode);\n    }\n}\nfunction logGlobalOperationEnd(opId, vm) {\n    if (isMeasureEnabled) {\n        const opName = getOperationName(opId);\n        const markName = isUndefined$1(vm) ? opName : getMarkName(opId, vm);\n        end(opName, markName);\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 1 /* Phase.Stop */, vm === null || vm === void 0 ? void 0 : vm.tagName, vm === null || vm === void 0 ? void 0 : vm.idx, vm === null || vm === void 0 ? void 0 : vm.renderMode, vm === null || vm === void 0 ? void 0 : vm.shadowMode);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isUpdatingTemplate = false;\nlet vmBeingRendered = null;\nfunction getVMBeingRendered() {\n    return vmBeingRendered;\n}\nfunction setVMBeingRendered(vm) {\n    vmBeingRendered = vm;\n}\nfunction validateSlots(vm, html) {\n    assertNotProd(); // this method should never leak to prod\n    const { cmpSlots } = vm;\n    const { slots = EmptyArray } = html;\n    for (const slotName in cmpSlots.slotAssignments) {\n        // eslint-disable-next-line @lwc/lwc-internal/no-production-assert\n        assert.isTrue(isArray$1(cmpSlots.slotAssignments[slotName]), `Slots can only be set to an array, instead received ${toString$1(cmpSlots.slotAssignments[slotName])} for slot \"${slotName}\" in ${vm}.`);\n        if (slotName !== '' && ArrayIndexOf.call(slots, slotName) === -1) {\n            // TODO [#1297]: this should never really happen because the compiler should always validate\n            // eslint-disable-next-line @lwc/lwc-internal/no-production-assert\n            logError(`Ignoring unknown provided slot name \"${slotName}\" in ${vm}. Check for a typo on the slot attribute.`, vm);\n        }\n    }\n}\nfunction validateLightDomTemplate(template, vm) {\n    if (template === defaultEmptyTemplate)\n        return;\n    if (vm.renderMode === 0 /* RenderMode.Light */) {\n        assert.isTrue(template.renderMode === 'light', `Light DOM components can't render shadow DOM templates. Add an 'lwc:render-mode=\"light\"' directive to the root template tag of ${getComponentTag(vm)}.`);\n    }\n    else {\n        assert.isTrue(isUndefined$1(template.renderMode), `Shadow DOM components template can't render light DOM templates. Either remove the 'lwc:render-mode' directive from ${getComponentTag(vm)} or set it to 'lwc:render-mode=\"shadow\"`);\n    }\n}\nfunction buildParseFragmentFn(createFragmentFn) {\n    return (strings, ...keys) => {\n        const cache = create(null);\n        return function () {\n            const { context: { hasScopedStyles, stylesheetToken }, shadowMode, renderer, } = getVMBeingRendered();\n            const hasStyleToken = !isUndefined$1(stylesheetToken);\n            const isSyntheticShadow = shadowMode === 1 /* ShadowMode.Synthetic */;\n            let cacheKey = 0;\n            if (hasStyleToken && hasScopedStyles) {\n                cacheKey |= 1 /* FragmentCache.HAS_SCOPED_STYLE */;\n            }\n            if (hasStyleToken && isSyntheticShadow) {\n                cacheKey |= 2 /* FragmentCache.SHADOW_MODE_SYNTHETIC */;\n            }\n            if (!isUndefined$1(cache[cacheKey])) {\n                return cache[cacheKey];\n            }\n            const classToken = hasScopedStyles && hasStyleToken ? ' ' + stylesheetToken : '';\n            const classAttrToken = hasScopedStyles && hasStyleToken ? ` class=\"${stylesheetToken}\"` : '';\n            const attrToken = hasStyleToken && isSyntheticShadow ? ' ' + stylesheetToken : '';\n            let htmlFragment = '';\n            for (let i = 0, n = keys.length; i < n; i++) {\n                switch (keys[i]) {\n                    case 0: // styleToken in existing class attr\n                        htmlFragment += strings[i] + classToken;\n                        break;\n                    case 1: // styleToken for added class attr\n                        htmlFragment += strings[i] + classAttrToken;\n                        break;\n                    case 2: // styleToken as attr\n                        htmlFragment += strings[i] + attrToken;\n                        break;\n                    case 3: // ${1}${2}\n                        htmlFragment += strings[i] + classAttrToken + attrToken;\n                        break;\n                }\n            }\n            htmlFragment += strings[strings.length - 1];\n            cache[cacheKey] = createFragmentFn(htmlFragment, renderer);\n            return cache[cacheKey];\n        };\n    };\n}\n// Note: at the moment this code executes, we don't have a renderer yet.\nconst parseFragment = buildParseFragmentFn((html, renderer) => {\n    const { createFragment } = renderer;\n    return createFragment(html);\n});\nconst parseSVGFragment = buildParseFragmentFn((html, renderer) => {\n    const { createFragment, getFirstChild } = renderer;\n    const fragment = createFragment('<svg>' + html + '</svg>');\n    return getFirstChild(fragment);\n});\nfunction evaluateTemplate(vm, html) {\n    if (true) {\n        assert.isTrue(isFunction$1(html), `evaluateTemplate() second argument must be an imported template instead of ${toString$1(html)}`);\n        // in dev-mode, we support hot swapping of templates, which means that\n        // the component instance might be attempting to use an old version of\n        // the template, while internally, we have a replacement for it.\n        html = getTemplateOrSwappedTemplate(html);\n    }\n    const isUpdatingTemplateInception = isUpdatingTemplate;\n    const vmOfTemplateBeingUpdatedInception = vmBeingRendered;\n    let vnodes = [];\n    runWithBoundaryProtection(vm, vm.owner, () => {\n        // pre\n        vmBeingRendered = vm;\n        logOperationStart(1 /* OperationId.Render */, vm);\n    }, () => {\n        // job\n        const { component, context, cmpSlots, cmpTemplate, tro } = vm;\n        tro.observe(() => {\n            // Reset the cache memoizer for template when needed.\n            if (html !== cmpTemplate) {\n                if (true) {\n                    validateLightDomTemplate(html, vm);\n                }\n                // Perf opt: do not reset the shadow root during the first rendering (there is\n                // nothing to reset).\n                if (!isNull(cmpTemplate)) {\n                    // It is important to reset the content to avoid reusing similar elements\n                    // generated from a different template, because they could have similar IDs,\n                    // and snabbdom just rely on the IDs.\n                    resetComponentRoot(vm);\n                }\n                // Check that the template was built by the compiler.\n                if (!isTemplateRegistered(html)) {\n                    throw new TypeError(`Invalid template returned by the render() method on ${vm}. It must return an imported template (e.g.: \\`import html from \"./${vm.def.name}.html\"\\`), instead, it has returned: ${toString$1(html)}.`);\n                }\n                vm.cmpTemplate = html;\n                // Create a brand new template cache for the swapped templated.\n                context.tplCache = create(null);\n                // Set the computeHasScopedStyles property in the context, to avoid recomputing it repeatedly.\n                context.hasScopedStyles = computeHasScopedStyles(html, vm);\n                // Update the scoping token on the host element.\n                updateStylesheetToken(vm, html);\n                // Evaluate, create stylesheet and cache the produced VNode for future\n                // re-rendering.\n                const stylesheetsContent = getStylesheetsContent(vm, html);\n                context.styleVNodes =\n                    stylesheetsContent.length === 0\n                        ? null\n                        : createStylesheet(vm, stylesheetsContent);\n            }\n            if (true) {\n                // validating slots in every rendering since the allocated content might change over time\n                validateSlots(vm, html);\n                // add the VM to the list of host VMs that can be re-rendered if html is swapped\n                setActiveVM(vm);\n            }\n            // reset the refs; they will be set during the tmpl() instantiation\n            vm.refVNodes = html.hasRefs ? create(null) : null;\n            // right before producing the vnodes, we clear up all internal references\n            // to custom elements from the template.\n            vm.velements = [];\n            // Set the global flag that template is being updated\n            isUpdatingTemplate = true;\n            vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);\n            const { styleVNodes } = context;\n            if (!isNull(styleVNodes)) {\n                ArrayUnshift.apply(vnodes, styleVNodes);\n            }\n        });\n    }, () => {\n        // post\n        isUpdatingTemplate = isUpdatingTemplateInception;\n        vmBeingRendered = vmOfTemplateBeingUpdatedInception;\n        logOperationEnd(1 /* OperationId.Render */, vm);\n    });\n    if (true) {\n        assert.invariant(isArray$1(vnodes), `Compiler should produce html functions that always return an array.`);\n    }\n    return vnodes;\n}\nfunction computeHasScopedStylesInStylesheets(stylesheets) {\n    if (hasStyles(stylesheets)) {\n        for (let i = 0; i < stylesheets.length; i++) {\n            if (isTrue(stylesheets[i][KEY__SCOPED_CSS])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction computeHasScopedStyles(template, vm) {\n    const { stylesheets } = template;\n    const vmStylesheets = !isUndefined$1(vm) ? vm.stylesheets : null;\n    return (computeHasScopedStylesInStylesheets(stylesheets) ||\n        computeHasScopedStylesInStylesheets(vmStylesheets));\n}\nfunction hasStyles(stylesheets) {\n    return !isUndefined$1(stylesheets) && !isNull(stylesheets) && stylesheets.length > 0;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isInvokingRender = false;\nlet vmBeingConstructed = null;\nfunction isBeingConstructed(vm) {\n    return vmBeingConstructed === vm;\n}\nfunction invokeComponentCallback(vm, fn, args) {\n    const { component, callHook, owner } = vm;\n    runWithBoundaryProtection(vm, owner, noop, () => {\n        callHook(component, fn, args);\n    }, noop);\n}\nfunction invokeComponentConstructor(vm, Ctor) {\n    const vmBeingConstructedInception = vmBeingConstructed;\n    let error;\n    logOperationStart(0 /* OperationId.Constructor */, vm);\n    vmBeingConstructed = vm;\n    /**\n     * Constructors don't need to be wrapped with a boundary because for root elements\n     * it should throw, while elements from template are already wrapped by a boundary\n     * associated to the diffing algo.\n     */\n    try {\n        // job\n        const result = new Ctor();\n        // Check indirectly if the constructor result is an instance of LightningElement. Using\n        // the \"instanceof\" operator would not work here since Locker Service provides its own\n        // implementation of LightningElement, so we indirectly check if the base constructor is\n        // invoked by accessing the component on the vm.\n        if (vmBeingConstructed.component !== result) {\n            throw new TypeError('Invalid component constructor, the class should extend LightningElement.');\n        }\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        logOperationEnd(0 /* OperationId.Constructor */, vm);\n        vmBeingConstructed = vmBeingConstructedInception;\n        if (!isUndefined$1(error)) {\n            addErrorComponentStack(vm, error);\n            // re-throwing the original error annotated after restoring the context\n            throw error; // eslint-disable-line no-unsafe-finally\n        }\n    }\n}\nfunction invokeComponentRenderMethod(vm) {\n    const { def: { render }, callHook, component, owner, } = vm;\n    const isRenderBeingInvokedInception = isInvokingRender;\n    const vmBeingRenderedInception = getVMBeingRendered();\n    let html;\n    let renderInvocationSuccessful = false;\n    runWithBoundaryProtection(vm, owner, () => {\n        // pre\n        isInvokingRender = true;\n        setVMBeingRendered(vm);\n    }, () => {\n        // job\n        vm.tro.observe(() => {\n            html = callHook(component, render);\n            renderInvocationSuccessful = true;\n        });\n    }, () => {\n        // post\n        isInvokingRender = isRenderBeingInvokedInception;\n        setVMBeingRendered(vmBeingRenderedInception);\n    });\n    // If render() invocation failed, process errorCallback in boundary and return an empty template\n    return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];\n}\nfunction invokeEventListener(vm, fn, thisValue, event) {\n    const { callHook, owner } = vm;\n    runWithBoundaryProtection(vm, owner, noop, () => {\n        // job\n        if (true) {\n            assert.isTrue(isFunction$1(fn), `Invalid event handler for event '${event.type}' on ${vm}.`);\n        }\n        callHook(thisValue, fn, [event]);\n    }, noop);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst signedTemplateMap = new Map();\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\nfunction registerComponent(\n// We typically expect a LightningElementConstructor, but technically you can call this with anything\nCtor, { tmpl }) {\n    if (isFunction$1(Ctor)) {\n        if (true) {\n            // There is no point in running this in production, because the version mismatch check relies\n            // on code comments which are stripped out in production by minifiers\n            checkVersionMismatch(Ctor, 'component');\n        }\n        signedTemplateMap.set(Ctor, tmpl);\n    }\n    // chaining this method as a way to wrap existing assignment of component constructor easily,\n    // without too much transformation\n    return Ctor;\n}\nfunction getComponentRegisteredTemplate(Ctor) {\n    return signedTemplateMap.get(Ctor);\n}\nfunction getTemplateReactiveObserver(vm) {\n    return createReactiveObserver(() => {\n        const { isDirty } = vm;\n        if (isFalse(isDirty)) {\n            markComponentAsDirty(vm);\n            scheduleRehydration(vm);\n        }\n    });\n}\nfunction renderComponent(vm) {\n    if (true) {\n        assert.invariant(vm.isDirty, `${vm} is not dirty.`);\n    }\n    vm.tro.reset();\n    const vnodes = invokeComponentRenderMethod(vm);\n    vm.isDirty = false;\n    vm.isScheduled = false;\n    return vnodes;\n}\nfunction markComponentAsDirty(vm) {\n    if (true) {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the component is already dirty.`);\n        assert.isFalse(isInvokingRender, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${vmBeingRendered}.`);\n        assert.isFalse(isUpdatingTemplate, `markComponentAsDirty() for ${vm} cannot be called while updating template of ${vmBeingRendered}.`);\n    }\n    vm.isDirty = true;\n}\nconst cmpEventListenerMap = new WeakMap();\nfunction getWrappedComponentsListener(vm, listener) {\n    if (!isFunction$1(listener)) {\n        throw new TypeError('Expected an EventListener but received ' + typeof listener); // avoiding problems with non-valid listeners\n    }\n    let wrappedListener = cmpEventListenerMap.get(listener);\n    if (isUndefined$1(wrappedListener)) {\n        wrappedListener = function (event) {\n            invokeEventListener(vm, listener, undefined, event);\n        };\n        cmpEventListenerMap.set(listener, wrappedListener);\n    }\n    return wrappedListener;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst Services = create(null);\nconst hooks = ['rendered', 'connected', 'disconnected'];\n/**\n * EXPERIMENTAL: This function allows for the registration of \"services\"\n * in LWC by exposing hooks into the component life-cycle. This API is\n * subject to change or being removed.\n */\nfunction register(service) {\n    if (true) {\n        assert.isTrue(isObject(service), `Invalid service declaration, ${service}: service must be an object`);\n    }\n    for (let i = 0; i < hooks.length; ++i) {\n        const hookName = hooks[i];\n        if (hookName in service) {\n            let l = Services[hookName];\n            if (isUndefined$1(l)) {\n                Services[hookName] = l = [];\n            }\n            ArrayPush$1.call(l, service[hookName]);\n        }\n    }\n}\nfunction invokeServiceHook(vm, cbs) {\n    if (true) {\n        assert.isTrue(isArray$1(cbs) && cbs.length > 0, `Optimize invokeServiceHook() to be invoked only when needed`);\n    }\n    const { component, def, context } = vm;\n    for (let i = 0, len = cbs.length; i < len; ++i) {\n        cbs[i].call(undefined, component, {}, def, context);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet idx = 0;\n/** The internal slot used to associate different objects the engine manipulates with the VM */\nconst ViewModelReflection = new WeakMap();\nfunction callHook(cmp, fn, args = []) {\n    return fn.apply(cmp, args);\n}\nfunction setHook(cmp, prop, newValue) {\n    cmp[prop] = newValue;\n}\nfunction getHook(cmp, prop) {\n    return cmp[prop];\n}\nfunction rerenderVM(vm) {\n    rehydrate(vm);\n}\nfunction connectRootElement(elm) {\n    const vm = getAssociatedVM(elm);\n    logGlobalOperationStart(7 /* OperationId.GlobalHydrate */, vm);\n    // Usually means moving the element from one place to another, which is observable via\n    // life-cycle hooks.\n    if (vm.state === 1 /* VMState.connected */) {\n        disconnectRootElement(elm);\n    }\n    runConnectedCallback(vm);\n    rehydrate(vm);\n    logGlobalOperationEnd(7 /* OperationId.GlobalHydrate */, vm);\n}\nfunction disconnectRootElement(elm) {\n    const vm = getAssociatedVM(elm);\n    resetComponentStateWhenRemoved(vm);\n}\nfunction appendVM(vm) {\n    rehydrate(vm);\n}\n// just in case the component comes back, with this we guarantee re-rendering it\n// while preventing any attempt to rehydration until after reinsertion.\nfunction resetComponentStateWhenRemoved(vm) {\n    const { state } = vm;\n    if (state !== 2 /* VMState.disconnected */) {\n        const { tro } = vm;\n        // Making sure that any observing record will not trigger the rehydrated on this vm\n        tro.reset();\n        runDisconnectedCallback(vm);\n        // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)\n        runChildNodesDisconnectedCallback(vm);\n        runLightChildNodesDisconnectedCallback(vm);\n    }\n    if (true) {\n        removeActiveVM(vm);\n    }\n}\n// this method is triggered by the diffing algo only when a vnode from the\n// old vnode.children is removed from the DOM.\nfunction removeVM(vm) {\n    if (true) {\n        assert.isTrue(vm.state === 1 /* VMState.connected */ || vm.state === 2 /* VMState.disconnected */, `${vm} must have been connected.`);\n    }\n    resetComponentStateWhenRemoved(vm);\n}\nfunction getNearestShadowAncestor(vm) {\n    let ancestor = vm.owner;\n    while (!isNull(ancestor) && ancestor.renderMode === 0 /* RenderMode.Light */) {\n        ancestor = ancestor.owner;\n    }\n    return ancestor;\n}\nfunction createVM(elm, ctor, renderer, options) {\n    const { mode, owner, tagName, hydrated } = options;\n    const def = getComponentInternalDef(ctor);\n    const vm = {\n        elm,\n        def,\n        idx: idx++,\n        state: 0 /* VMState.created */,\n        isScheduled: false,\n        isDirty: true,\n        tagName,\n        mode,\n        owner,\n        refVNodes: null,\n        children: EmptyArray,\n        aChildren: EmptyArray,\n        velements: EmptyArray,\n        cmpProps: create(null),\n        cmpFields: create(null),\n        cmpSlots: { slotAssignments: create(null) },\n        cmpTemplate: null,\n        hydrated: Boolean(hydrated),\n        renderMode: def.renderMode,\n        context: {\n            stylesheetToken: undefined,\n            hasTokenInClass: undefined,\n            hasTokenInAttribute: undefined,\n            hasScopedStyles: undefined,\n            styleVNodes: null,\n            tplCache: EmptyObject,\n            wiredConnecting: EmptyArray,\n            wiredDisconnecting: EmptyArray,\n        },\n        // Properties set right after VM creation.\n        tro: null,\n        shadowMode: null,\n        stylesheets: null,\n        // Properties set by the LightningElement constructor.\n        component: null,\n        shadowRoot: null,\n        renderRoot: null,\n        callHook,\n        setHook,\n        getHook,\n        renderer,\n    };\n    if (true) {\n        vm.debugInfo = create(null);\n    }\n    vm.stylesheets = computeStylesheets(vm, def.ctor);\n    vm.shadowMode = computeShadowMode(vm, renderer);\n    vm.tro = getTemplateReactiveObserver(vm);\n    if (true) {\n        vm.toString = () => {\n            return `[object:vm ${def.name} (${vm.idx})]`;\n        };\n        if (lwcRuntimeFlags.ENABLE_FORCE_NATIVE_SHADOW_MODE_FOR_TEST) {\n            vm.shadowMode = 0 /* ShadowMode.Native */;\n        }\n    }\n    // Create component instance associated to the vm and the element.\n    invokeComponentConstructor(vm, def.ctor);\n    // Initializing the wire decorator per instance only when really needed\n    if (hasWireAdapters(vm)) {\n        installWireAdapters(vm);\n    }\n    return vm;\n}\nfunction validateComponentStylesheets(vm, stylesheets) {\n    let valid = true;\n    const validate = (arrayOrStylesheet) => {\n        if (isArray$1(arrayOrStylesheet)) {\n            for (let i = 0; i < arrayOrStylesheet.length; i++) {\n                validate(arrayOrStylesheet[i]);\n            }\n        }\n        else if (!isFunction$1(arrayOrStylesheet)) {\n            // function assumed to be a stylesheet factory\n            valid = false;\n        }\n    };\n    if (!isArray$1(stylesheets)) {\n        valid = false;\n    }\n    else {\n        validate(stylesheets);\n    }\n    return valid;\n}\n// Validate and flatten any stylesheets defined as `static stylesheets`\nfunction computeStylesheets(vm, ctor) {\n    warnOnStylesheetsMutation(ctor);\n    const { stylesheets } = ctor;\n    if (!isUndefined$1(stylesheets)) {\n        const valid = validateComponentStylesheets(vm, stylesheets);\n        if (valid) {\n            return flattenStylesheets(stylesheets);\n        }\n        else if (true) {\n            logError(`static stylesheets must be an array of CSS stylesheets. Found invalid stylesheets on <${vm.tagName}>`, vm);\n        }\n    }\n    return null;\n}\nfunction warnOnStylesheetsMutation(ctor) {\n    if (true) {\n        let { stylesheets } = ctor;\n        defineProperty(ctor, 'stylesheets', {\n            enumerable: true,\n            configurable: true,\n            get() {\n                return stylesheets;\n            },\n            set(newValue) {\n                logWarnOnce(`Dynamically setting the \"stylesheets\" static property on ${ctor.name} ` +\n                    'will not affect the stylesheets injected.');\n                stylesheets = newValue;\n            },\n        });\n    }\n}\nfunction computeShadowMode(vm, renderer) {\n    const { def } = vm;\n    const { isSyntheticShadowDefined, isNativeShadowDefined } = renderer;\n    let shadowMode;\n    if (isSyntheticShadowDefined) {\n        if (def.renderMode === 0 /* RenderMode.Light */) {\n            // ShadowMode.Native implies \"not synthetic shadow\" which is consistent with how\n            // everything defaults to native when the synthetic shadow polyfill is unavailable.\n            shadowMode = 0 /* ShadowMode.Native */;\n        }\n        else if (isNativeShadowDefined) {\n            // Not combined with above condition because @lwc/features only supports identifiers in\n            // the if-condition.\n            if (lwcRuntimeFlags.ENABLE_MIXED_SHADOW_MODE) {\n                if (def.shadowSupportMode === \"any\" /* ShadowSupportMode.Any */) {\n                    shadowMode = 0 /* ShadowMode.Native */;\n                }\n                else {\n                    const shadowAncestor = getNearestShadowAncestor(vm);\n                    if (!isNull(shadowAncestor) &&\n                        shadowAncestor.shadowMode === 0 /* ShadowMode.Native */) {\n                        // Transitive support for native Shadow DOM. A component in native mode\n                        // transitively opts all of its descendants into native.\n                        shadowMode = 0 /* ShadowMode.Native */;\n                    }\n                    else {\n                        // Synthetic if neither this component nor any of its ancestors are configured\n                        // to be native.\n                        shadowMode = 1 /* ShadowMode.Synthetic */;\n                    }\n                }\n            }\n            else {\n                shadowMode = 1 /* ShadowMode.Synthetic */;\n            }\n        }\n        else {\n            // Synthetic if there is no native Shadow DOM support.\n            shadowMode = 1 /* ShadowMode.Synthetic */;\n        }\n    }\n    else {\n        // Native if the synthetic shadow polyfill is unavailable.\n        shadowMode = 0 /* ShadowMode.Native */;\n    }\n    return shadowMode;\n}\nfunction assertIsVM(obj) {\n    if (isNull(obj) || !isObject(obj) || !('renderRoot' in obj)) {\n        throw new TypeError(`${obj} is not a VM.`);\n    }\n}\nfunction associateVM(obj, vm) {\n    ViewModelReflection.set(obj, vm);\n}\nfunction getAssociatedVM(obj) {\n    const vm = ViewModelReflection.get(obj);\n    if (true) {\n        assertIsVM(vm);\n    }\n    return vm;\n}\nfunction getAssociatedVMIfPresent(obj) {\n    const maybeVm = ViewModelReflection.get(obj);\n    if (true) {\n        if (!isUndefined$1(maybeVm)) {\n            assertIsVM(maybeVm);\n        }\n    }\n    return maybeVm;\n}\nfunction rehydrate(vm) {\n    if (isTrue(vm.isDirty)) {\n        const children = renderComponent(vm);\n        patchShadowRoot(vm, children);\n    }\n}\nfunction patchShadowRoot(vm, newCh) {\n    const { renderRoot, children: oldCh, renderer } = vm;\n    // caching the new children collection\n    vm.children = newCh;\n    if (newCh.length > 0 || oldCh.length > 0) {\n        // patch function mutates vnodes by adding the element reference,\n        // however, if patching fails it contains partial changes.\n        if (oldCh !== newCh) {\n            runWithBoundaryProtection(vm, vm, () => {\n                // pre\n                logOperationStart(2 /* OperationId.Patch */, vm);\n            }, () => {\n                // job\n                patchChildren(oldCh, newCh, renderRoot, renderer);\n            }, () => {\n                // post\n                logOperationEnd(2 /* OperationId.Patch */, vm);\n            });\n        }\n    }\n    if (vm.state === 1 /* VMState.connected */) {\n        // If the element is connected, that means connectedCallback was already issued, and\n        // any successive rendering should finish with the call to renderedCallback, otherwise\n        // the connectedCallback will take care of calling it in the right order at the end of\n        // the current rehydration process.\n        runRenderedCallback(vm);\n    }\n}\nfunction runRenderedCallback(vm) {\n    const { def: { renderedCallback }, } = vm;\n    const { rendered } = Services;\n    if (rendered) {\n        invokeServiceHook(vm, rendered);\n    }\n    if (!isUndefined$1(renderedCallback)) {\n        logOperationStart(4 /* OperationId.RenderedCallback */, vm);\n        invokeComponentCallback(vm, renderedCallback);\n        logOperationEnd(4 /* OperationId.RenderedCallback */, vm);\n    }\n}\nlet rehydrateQueue = [];\nfunction flushRehydrationQueue() {\n    logGlobalOperationStart(8 /* OperationId.GlobalRehydrate */);\n    if (true) {\n        assert.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);\n    }\n    const vms = rehydrateQueue.sort((a, b) => a.idx - b.idx);\n    rehydrateQueue = []; // reset to a new queue\n    for (let i = 0, len = vms.length; i < len; i += 1) {\n        const vm = vms[i];\n        try {\n            rehydrate(vm);\n        }\n        catch (error) {\n            if (i + 1 < len) {\n                // pieces of the queue are still pending to be rehydrated, those should have priority\n                if (rehydrateQueue.length === 0) {\n                    addCallbackToNextTick(flushRehydrationQueue);\n                }\n                ArrayUnshift.apply(rehydrateQueue, ArraySlice.call(vms, i + 1));\n            }\n            // we need to end the measure before throwing.\n            logGlobalOperationEnd(8 /* OperationId.GlobalRehydrate */);\n            // re-throwing the original error will break the current tick, but since the next tick is\n            // already scheduled, it should continue patching the rest.\n            throw error; // eslint-disable-line no-unsafe-finally\n        }\n    }\n    logGlobalOperationEnd(8 /* OperationId.GlobalRehydrate */);\n}\nfunction runConnectedCallback(vm) {\n    const { state } = vm;\n    if (state === 1 /* VMState.connected */) {\n        return; // nothing to do since it was already connected\n    }\n    vm.state = 1 /* VMState.connected */;\n    // reporting connection\n    const { connected } = Services;\n    if (connected) {\n        invokeServiceHook(vm, connected);\n    }\n    if (hasWireAdapters(vm)) {\n        connectWireAdapters(vm);\n    }\n    const { connectedCallback } = vm.def;\n    if (!isUndefined$1(connectedCallback)) {\n        logOperationStart(3 /* OperationId.ConnectedCallback */, vm);\n        invokeComponentCallback(vm, connectedCallback);\n        logOperationEnd(3 /* OperationId.ConnectedCallback */, vm);\n    }\n}\nfunction hasWireAdapters(vm) {\n    return getOwnPropertyNames$1(vm.def.wire).length > 0;\n}\nfunction runDisconnectedCallback(vm) {\n    if (true) {\n        assert.isTrue(vm.state !== 2 /* VMState.disconnected */, `${vm} must be inserted.`);\n    }\n    if (isFalse(vm.isDirty)) {\n        // this guarantees that if the component is reused/reinserted,\n        // it will be re-rendered because we are disconnecting the reactivity\n        // linking, so mutations are not automatically reflected on the state\n        // of disconnected components.\n        vm.isDirty = true;\n    }\n    vm.state = 2 /* VMState.disconnected */;\n    // reporting disconnection\n    const { disconnected } = Services;\n    if (disconnected) {\n        invokeServiceHook(vm, disconnected);\n    }\n    if (hasWireAdapters(vm)) {\n        disconnectWireAdapters(vm);\n    }\n    const { disconnectedCallback } = vm.def;\n    if (!isUndefined$1(disconnectedCallback)) {\n        logOperationStart(5 /* OperationId.DisconnectedCallback */, vm);\n        invokeComponentCallback(vm, disconnectedCallback);\n        logOperationEnd(5 /* OperationId.DisconnectedCallback */, vm);\n    }\n}\nfunction runChildNodesDisconnectedCallback(vm) {\n    const { velements: vCustomElementCollection } = vm;\n    // Reporting disconnection for every child in inverse order since they are\n    // inserted in reserved order.\n    for (let i = vCustomElementCollection.length - 1; i >= 0; i -= 1) {\n        const { elm } = vCustomElementCollection[i];\n        // There are two cases where the element could be undefined:\n        // * when there is an error during the construction phase, and an error\n        //   boundary picks it, there is a possibility that the VCustomElement\n        //   is not properly initialized, and therefore is should be ignored.\n        // * when slotted custom element is not used by the element where it is\n        //   slotted into it, as  a result, the custom element was never\n        //   initialized.\n        if (!isUndefined$1(elm)) {\n            const childVM = getAssociatedVMIfPresent(elm);\n            // The VM associated with the element might be associated undefined\n            // in the case where the VM failed in the middle of its creation,\n            // eg: constructor throwing before invoking super().\n            if (!isUndefined$1(childVM)) {\n                resetComponentStateWhenRemoved(childVM);\n            }\n        }\n    }\n}\nfunction runLightChildNodesDisconnectedCallback(vm) {\n    const { aChildren: adoptedChildren } = vm;\n    recursivelyDisconnectChildren(adoptedChildren);\n}\n/**\n * The recursion doesn't need to be a complete traversal of the vnode graph,\n * instead it can be partial, when a custom element vnode is found, we don't\n * need to continue into its children because by attempting to disconnect the\n * custom element itself will trigger the removal of anything slotted or anything\n * defined on its shadow.\n */\nfunction recursivelyDisconnectChildren(vnodes) {\n    for (let i = 0, len = vnodes.length; i < len; i += 1) {\n        const vnode = vnodes[i];\n        if (!isNull(vnode) && !isUndefined$1(vnode.elm)) {\n            switch (vnode.type) {\n                case 2 /* VNodeType.Element */:\n                    recursivelyDisconnectChildren(vnode.children);\n                    break;\n                case 3 /* VNodeType.CustomElement */: {\n                    const vm = getAssociatedVM(vnode.elm);\n                    resetComponentStateWhenRemoved(vm);\n                    break;\n                }\n            }\n        }\n    }\n}\n// This is a super optimized mechanism to remove the content of the root node (shadow root\n// for shadow DOM components and the root element itself for light DOM) without having to go\n// into snabbdom. Especially useful when the reset is a consequence of an error, in which case the\n// children VNodes might not be representing the current state of the DOM.\nfunction resetComponentRoot(vm) {\n    const { children, renderRoot, renderer: { remove }, } = vm;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        if (!isNull(child) && !isUndefined$1(child.elm)) {\n            remove(child.elm, renderRoot);\n        }\n    }\n    vm.children = EmptyArray;\n    runChildNodesDisconnectedCallback(vm);\n    vm.velements = EmptyArray;\n}\nfunction scheduleRehydration(vm) {\n    if (isTrue(vm.isScheduled)) {\n        return;\n    }\n    vm.isScheduled = true;\n    if (rehydrateQueue.length === 0) {\n        addCallbackToNextTick(flushRehydrationQueue);\n    }\n    ArrayPush$1.call(rehydrateQueue, vm);\n}\nfunction getErrorBoundaryVM(vm) {\n    let currentVm = vm;\n    while (!isNull(currentVm)) {\n        if (!isUndefined$1(currentVm.def.errorCallback)) {\n            return currentVm;\n        }\n        currentVm = currentVm.owner;\n    }\n}\nfunction runWithBoundaryProtection(vm, owner, pre, job, post) {\n    let error;\n    pre();\n    try {\n        job();\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        post();\n        if (!isUndefined$1(error)) {\n            addErrorComponentStack(vm, error);\n            const errorBoundaryVm = isNull(owner) ? undefined : getErrorBoundaryVM(owner);\n            if (isUndefined$1(errorBoundaryVm)) {\n                throw error; // eslint-disable-line no-unsafe-finally\n            }\n            resetComponentRoot(vm); // remove offenders\n            logOperationStart(6 /* OperationId.ErrorCallback */, vm);\n            // error boundaries must have an ErrorCallback\n            const errorCallback = errorBoundaryVm.def.errorCallback;\n            invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);\n            logOperationEnd(6 /* OperationId.ErrorCallback */, vm);\n        }\n    }\n}\nfunction forceRehydration(vm) {\n    // if we must reset the shadowRoot content and render the template\n    // from scratch on an active instance, the way to force the reset\n    // is by replacing the value of old template, which is used during\n    // to determine if the template has changed or not during the rendering\n    // process. If the template returned by render() is different from the\n    // previous stored template, the styles will be reset, along with the\n    // content of the shadowRoot, this way we can guarantee that all children\n    // elements will be throw away, and new instances will be created.\n    vm.cmpTemplate = () => [];\n    if (isFalse(vm.isDirty)) {\n        // forcing the vm to rehydrate in the next tick\n        markComponentAsDirty(vm);\n        scheduleRehydration(vm);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n//\n// The goal of this code is to detect invalid cross-root ARIA references in synthetic shadow DOM.\n// These invalid references should be fixed before the offending components can be migrated to native shadow DOM.\n// When invalid usage is detected, we warn in dev mode and call the reporting API if enabled.\n// See: https://sfdc.co/synthetic-aria\n//\n// Use the unpatched native getElementById/querySelectorAll rather than the synthetic one\nconst getElementById = _globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID];\nconst querySelectorAll = _globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL];\n// This is a \"handoff\" from synthetic-shadow to engine-core  we want to clean up after ourselves\n// so nobody else can misuse these global APIs.\ndelete _globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID];\ndelete _globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL];\nfunction isSyntheticShadowRootInstance(rootNode) {\n    return rootNode !== document && isTrue(rootNode.synthetic);\n}\nfunction reportViolation$1(source, target, attrName) {\n    // The vm is either for the source, the target, or both. Either one or both must be using synthetic\n    // shadow for a violation to be detected.\n    let vm = getAssociatedVMIfPresent(source.getRootNode().host);\n    if (isUndefined$1(vm)) {\n        vm = getAssociatedVMIfPresent(target.getRootNode().host);\n    }\n    if (isUndefined$1(vm)) {\n        // vm should never be undefined here, but just to be safe, bail out and don't report\n        return;\n    }\n    report(\"CrossRootAriaInSyntheticShadow\" /* ReportingEventId.CrossRootAriaInSyntheticShadow */, {\n        tagName: vm.tagName,\n        attributeName: attrName,\n    });\n    if (true) {\n        // Avoid excessively logging to the console in the case of duplicates.\n        logWarnOnce(`Element <${source.tagName.toLowerCase()}> uses attribute \"${attrName}\" to reference element ` +\n            `<${target.tagName.toLowerCase()}>, which is not in the same shadow root. This will break in native shadow DOM. ` +\n            `For details, see: https://sfdc.co/synthetic-aria`, vm);\n    }\n}\nfunction parseIdRefAttributeValue(attrValue) {\n    // split on whitespace and skip empty strings after splitting\n    return isString(attrValue) ? ArrayFilter.call(StringSplit.call(attrValue, /\\s+/), Boolean) : [];\n}\nfunction detectSyntheticCrossRootAria(elm, attrName, attrValue) {\n    const root = elm.getRootNode();\n    if (!isSyntheticShadowRootInstance(root)) {\n        return;\n    }\n    if (attrName === 'id') {\n        // elm is the target, find the source\n        if (!isString(attrValue) || attrValue.length === 0) {\n            // if our id is null or empty, nobody can reference us\n            return;\n        }\n        for (const idRefAttrName of ID_REFERENCING_ATTRIBUTES_SET) {\n            // Query all global elements with this attribute. The attribute selector syntax `~=` is for values\n            // that reference multiple IDs, separated by whitespace.\n            const query = `[${idRefAttrName}~=\"${CSS.escape(attrValue)}\"]`;\n            const sourceElements = querySelectorAll.call(document, query);\n            for (let i = 0; i < sourceElements.length; i++) {\n                const sourceElement = sourceElements[i];\n                const sourceRoot = sourceElement.getRootNode();\n                if (sourceRoot !== root) {\n                    reportViolation$1(sourceElement, elm, idRefAttrName);\n                    break;\n                }\n            }\n        }\n    }\n    else {\n        // elm is the source, find the target\n        const ids = parseIdRefAttributeValue(attrValue);\n        for (const id of ids) {\n            const target = getElementById.call(document, id);\n            if (!isNull(target)) {\n                const targetRoot = target.getRootNode();\n                if (targetRoot !== root) {\n                    // target element's shadow root is not the same as ours\n                    reportViolation$1(elm, target, attrName);\n                }\n            }\n        }\n    }\n}\nlet enabled = false;\n// We want to avoid patching globals whenever possible, so this should be tree-shaken out in prod-mode and if\n// reporting is not enabled. It should also only run once\nfunction enableDetection$1() {\n    if (enabled) {\n        return; // don't double-apply the patches\n    }\n    enabled = true;\n    const { setAttribute } = Element.prototype;\n    // Detect calling `setAttribute` to set an idref or an id\n    assign(Element.prototype, {\n        setAttribute(attrName, attrValue) {\n            setAttribute.call(this, attrName, attrValue);\n            if (attrName === 'id' || ID_REFERENCING_ATTRIBUTES_SET.has(attrName)) {\n                detectSyntheticCrossRootAria(this, attrName, attrValue);\n            }\n        },\n    });\n    // Detect `elm.id = 'foo'`\n    const idDescriptor = getOwnPropertyDescriptor$1(Element.prototype, 'id');\n    if (!isUndefined$1(idDescriptor)) {\n        const { get, set } = idDescriptor;\n        // These should always be a getter and a setter, but if someone is monkeying with the global descriptor, ignore it\n        if (isFunction$1(get) && isFunction$1(set)) {\n            defineProperty(Element.prototype, 'id', {\n                get() {\n                    return get.call(this);\n                },\n                set(value) {\n                    set.call(this, value);\n                    detectSyntheticCrossRootAria(this, 'id', value);\n                },\n                // On the default descriptor for 'id', enumerable and configurable are true\n                enumerable: true,\n                configurable: true,\n            });\n        }\n    }\n}\n// Our detection logic relies on some modern browser features. We can just skip reporting the data\n// for unsupported browsers\nfunction supportsCssEscape() {\n    return typeof CSS !== 'undefined' && isFunction$1(CSS.escape);\n}\n// If this page is not using synthetic shadow, then we don't need to install detection. Note\n// that we are assuming synthetic shadow is loaded before LWC.\nfunction isSyntheticShadowLoaded() {\n    // We should probably be calling `renderer.isSyntheticShadowDefined`, but 1) we don't have access to the renderer,\n    // and 2) this code needs to run in @lwc/engine-core, so it can access `logWarn()` and `report()`.\n    return hasOwnProperty$1.call(Element.prototype, KEY__SHADOW_TOKEN);\n}\n// Detecting cross-root ARIA in synthetic shadow only makes sense for the browser\nif (supportsCssEscape() && isSyntheticShadowLoaded()) {\n    // Always run detection in dev mode, so we can at least print to the console\n    if (true) {\n        enableDetection$1();\n    }\n    else {}\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n//\n// The goal of this code is to detect usages of non-standard reflected ARIA properties. These are caused by\n// legacy non-standard Element.prototype extensions added by the @lwc/aria-reflection package.\n//\n// See the README for @lwc/aria-reflection\nconst NON_STANDARD_ARIA_PROPS = [\n    'ariaActiveDescendant',\n    'ariaControls',\n    'ariaDescribedBy',\n    'ariaDetails',\n    'ariaErrorMessage',\n    'ariaFlowTo',\n    'ariaLabelledBy',\n    'ariaOwns',\n];\nfunction isLightningElement(elm) {\n    // The former case is for `this.prop` (inside component) and the latter is for `element.prop` (outside component).\n    // In both cases, we apply the non-standard prop even when the global polyfill is disabled, so this is kosher.\n    return elm instanceof LightningElement || elm instanceof BaseBridgeElement;\n}\nfunction findVM(elm) {\n    // If it's a shadow DOM component, then it has a host\n    const { host } = elm.getRootNode();\n    const vm = isUndefined$1(host) ? undefined : getAssociatedVMIfPresent(host);\n    if (!isUndefined$1(vm)) {\n        return vm;\n    }\n    // Else it might be a light DOM component. Walk up the tree trying to find the owner\n    let parentElement = elm;\n    while (!isNull((parentElement = parentElement.parentElement))) {\n        if (isLightningElement(parentElement)) {\n            const vm = getAssociatedVMIfPresent(parentElement);\n            if (!isUndefined$1(vm)) {\n                return vm;\n            }\n        }\n    }\n    // If we return undefined, it's because the element was rendered wholly outside a LightningElement\n}\nfunction checkAndReportViolation(elm, prop, isSetter, setValue) {\n    if (!isLightningElement(elm)) {\n        const vm = findVM(elm);\n        if (true) {\n            logWarnOnce(`Element <${elm.tagName.toLowerCase()}> ` +\n                (isUndefined$1(vm) ? '' : `owned by <${vm.elm.tagName.toLowerCase()}> `) +\n                `uses non-standard property \"${prop}\". This will be removed in a future version of LWC. ` +\n                `See https://sfdc.co/deprecated-aria`);\n        }\n        let setValueType;\n        if (isSetter) {\n            // `typeof null` is \"object\" which is not very useful for detecting null.\n            // We mostly want to know null vs undefined vs other types here, due to\n            // https://github.com/salesforce/lwc/issues/3284\n            setValueType = isNull(setValue) ? 'null' : typeof setValue;\n        }\n        report(\"NonStandardAriaReflection\" /* ReportingEventId.NonStandardAriaReflection */, {\n            tagName: vm === null || vm === void 0 ? void 0 : vm.tagName,\n            propertyName: prop,\n            isSetter,\n            setValueType,\n        });\n    }\n}\nfunction enableDetection() {\n    const { prototype } = Element;\n    for (const prop of NON_STANDARD_ARIA_PROPS) {\n        const descriptor = getOwnPropertyDescriptor$1(prototype, prop);\n        // The descriptor should exist because the @lwc/aria-reflection polyfill has run by now.\n        // This happens automatically because of the ordering of imports.\n        if (true) {\n            /* istanbul ignore if */\n            if (isUndefined$1(descriptor) ||\n                isUndefined$1(descriptor.get) ||\n                isUndefined$1(descriptor.set)) {\n                // should never happen\n                throw new Error('detect-non-standard-aria.ts loaded before @lwc/aria-reflection');\n            }\n        }\n        // @ts-ignore\n        const { get, set } = descriptor;\n        defineProperty(prototype, prop, {\n            get() {\n                checkAndReportViolation(this, prop, false, undefined);\n                return get.call(this);\n            },\n            set(val) {\n                checkAndReportViolation(this, prop, true, val);\n                return set.call(this, val);\n            },\n            configurable: true,\n            enumerable: true,\n        });\n    }\n}\n// No point in running this code if we're not in a browser, or if the global polyfill is not loaded\n{\n    if (!lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {\n        // Always run detection in dev mode, so we can at least print to the console\n        if (true) {\n            enableDetection();\n        }\n        else {}\n    }\n}\n\n/*\n * Copyright (c) 2022, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// flag indicating if the hydration recovered from the DOM mismatch\nlet hasMismatch = false;\nfunction hydrateRoot(vm) {\n    hasMismatch = false;\n    runConnectedCallback(vm);\n    hydrateVM(vm);\n    if (hasMismatch) {\n        logError('Hydration completed with errors.', vm);\n    }\n}\nfunction hydrateVM(vm) {\n    const children = renderComponent(vm);\n    vm.children = children;\n    const { renderRoot: parentNode, renderer: { getFirstChild }, } = vm;\n    hydrateChildren(getFirstChild(parentNode), children, parentNode, vm);\n    runRenderedCallback(vm);\n}\nfunction hydrateNode(node, vnode, renderer) {\n    var _a, _b;\n    let hydratedNode;\n    switch (vnode.type) {\n        case 0 /* VNodeType.Text */:\n            // VText has no special capability, fallback to the owner's renderer\n            hydratedNode = hydrateText(node, vnode, renderer);\n            break;\n        case 1 /* VNodeType.Comment */:\n            // VComment has no special capability, fallback to the owner's renderer\n            hydratedNode = hydrateComment(node, vnode, renderer);\n            break;\n        case 4 /* VNodeType.Static */:\n            // VStatic are cacheable and cannot have custom renderer associated to them\n            hydratedNode = hydrateStaticElement(node, vnode, renderer);\n            break;\n        case 5 /* VNodeType.Fragment */:\n            // a fragment does not represent any element, therefore there is no need to use a custom renderer.\n            hydratedNode = hydrateFragment(node, vnode, renderer);\n            break;\n        case 2 /* VNodeType.Element */:\n            hydratedNode = hydrateElement(node, vnode, (_a = vnode.data.renderer) !== null && _a !== void 0 ? _a : renderer);\n            break;\n        case 3 /* VNodeType.CustomElement */:\n            hydratedNode = hydrateCustomElement(node, vnode, (_b = vnode.data.renderer) !== null && _b !== void 0 ? _b : renderer);\n            break;\n    }\n    return renderer.nextSibling(hydratedNode);\n}\nconst NODE_VALUE_PROP = 'nodeValue';\nconst PARENT_NODE_PROP = 'parentNode';\nconst TAG_NAME_PROP = 'tagName';\nfunction textNodeContentsAreEqual(node, vnode, renderer) {\n    const { getProperty } = renderer;\n    const nodeValue = getProperty(node, NODE_VALUE_PROP);\n    if (nodeValue === vnode.text) {\n        return true;\n    }\n    // Special case for empty text nodes  these are serialized differently on the server\n    // See https://github.com/salesforce/lwc/pull/2656\n    if (nodeValue === '\\u200D' && vnode.text === '') {\n        return true;\n    }\n    // Special case for text nodes inside `<style>` tags  these are escaped when rendered server-size,\n    // but not when generated by the engine client-side.\n    const parentNode = getProperty(node, PARENT_NODE_PROP);\n    // Should never be null, but just to be safe, we check.\n    /* istanbul ignore else */\n    if (!isNull(parentNode)) {\n        const tagName = getProperty(parentNode, TAG_NAME_PROP);\n        // If the tagName is STYLE, then the following condition should always be true.\n        // The LWC compiler blocks using `<style>`s inside of templates, so it should be impossible\n        // for component authors to render different `<style>` text content on the client and server.\n        // But just to be safe, we check.\n        /* istanbul ignore next */\n        if (tagName === 'STYLE' && htmlEscape(vnode.text) === nodeValue) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction hydrateText(node, vnode, renderer) {\n    var _a;\n    if (!hasCorrectNodeType(vnode, node, 3 /* EnvNodeTypes.TEXT */, renderer)) {\n        return handleMismatch(node, vnode, renderer);\n    }\n    if (true) {\n        if (!textNodeContentsAreEqual(node, vnode, renderer)) {\n            logWarn('Hydration mismatch: text values do not match, will recover from the difference', vnode.owner);\n        }\n    }\n    const { setText } = renderer;\n    setText(node, (_a = vnode.text) !== null && _a !== void 0 ? _a : null);\n    vnode.elm = node;\n    return node;\n}\nfunction hydrateComment(node, vnode, renderer) {\n    var _a;\n    if (!hasCorrectNodeType(vnode, node, 8 /* EnvNodeTypes.COMMENT */, renderer)) {\n        return handleMismatch(node, vnode, renderer);\n    }\n    if (true) {\n        const { getProperty } = renderer;\n        const nodeValue = getProperty(node, NODE_VALUE_PROP);\n        if (nodeValue !== vnode.text) {\n            logWarn('Hydration mismatch: comment values do not match, will recover from the difference', vnode.owner);\n        }\n    }\n    const { setProperty } = renderer;\n    setProperty(node, NODE_VALUE_PROP, (_a = vnode.text) !== null && _a !== void 0 ? _a : null);\n    vnode.elm = node;\n    return node;\n}\nfunction hydrateStaticElement(elm, vnode, renderer) {\n    if (!areCompatibleNodes(vnode.fragment, elm, vnode, renderer)) {\n        return handleMismatch(elm, vnode, renderer);\n    }\n    vnode.elm = elm;\n    return elm;\n}\nfunction hydrateFragment(elm, vnode, renderer) {\n    const { children, owner } = vnode;\n    hydrateChildren(elm, children, renderer.getProperty(elm, 'parentNode'), owner);\n    return (vnode.elm = children[children.length - 1].elm);\n}\nfunction hydrateElement(elm, vnode, renderer) {\n    if (!hasCorrectNodeType(vnode, elm, 1 /* EnvNodeTypes.ELEMENT */, renderer) ||\n        !isMatchingElement(vnode, elm, renderer)) {\n        return handleMismatch(elm, vnode, renderer);\n    }\n    vnode.elm = elm;\n    const { owner } = vnode;\n    const { context } = vnode.data;\n    const isDomManual = Boolean(!isUndefined$1(context) && !isUndefined$1(context.lwc) && context.lwc.dom === \"manual\" /* LwcDomMode.Manual */);\n    if (isDomManual) {\n        // it may be that this element has lwc:inner-html, we need to diff and in case are the same,\n        // remove the innerHTML from props so it reuses the existing dom elements.\n        const { data: { props }, } = vnode;\n        const { getProperty } = renderer;\n        if (!isUndefined$1(props) && !isUndefined$1(props.innerHTML)) {\n            if (getProperty(elm, 'innerHTML') === props.innerHTML) {\n                // Do a shallow clone since VNodeData may be shared across VNodes due to hoist optimization\n                vnode.data = Object.assign(Object.assign({}, vnode.data), { props: cloneAndOmitKey(props, 'innerHTML') });\n            }\n            else {\n                if (true) {\n                    logWarn(`Mismatch hydrating element <${getProperty(elm, 'tagName').toLowerCase()}>: innerHTML values do not match for element, will recover from the difference`, owner);\n                }\n            }\n        }\n    }\n    patchElementPropsAndAttrs(vnode, renderer);\n    if (!isDomManual) {\n        const { getFirstChild } = renderer;\n        hydrateChildren(getFirstChild(elm), vnode.children, elm, owner);\n    }\n    return elm;\n}\nfunction hydrateCustomElement(elm, vnode, renderer) {\n    if (!hasCorrectNodeType(vnode, elm, 1 /* EnvNodeTypes.ELEMENT */, renderer) ||\n        !isMatchingElement(vnode, elm, renderer)) {\n        return handleMismatch(elm, vnode, renderer);\n    }\n    const { sel, mode, ctor, owner } = vnode;\n    const vm = createVM(elm, ctor, renderer, {\n        mode,\n        owner,\n        tagName: sel,\n        hydrated: true,\n    });\n    vnode.elm = elm;\n    vnode.vm = vm;\n    allocateChildren(vnode, vm);\n    patchElementPropsAndAttrs(vnode, renderer);\n    // Insert hook section:\n    if (true) {\n        assert.isTrue(vm.state === 0 /* VMState.created */, `${vm} cannot be recycled.`);\n    }\n    runConnectedCallback(vm);\n    if (vm.renderMode !== 0 /* RenderMode.Light */) {\n        const { getFirstChild } = renderer;\n        // VM is not rendering in Light DOM, we can proceed and hydrate the slotted content.\n        // Note: for Light DOM, this is handled while hydrating the VM\n        hydrateChildren(getFirstChild(elm), vnode.children, elm, vm);\n    }\n    hydrateVM(vm);\n    return elm;\n}\nfunction hydrateChildren(node, children, parentNode, owner) {\n    let hasWarned = false;\n    let nextNode = node;\n    let anchor = null;\n    const { renderer } = owner;\n    for (let i = 0; i < children.length; i++) {\n        const childVnode = children[i];\n        if (!isNull(childVnode)) {\n            if (nextNode) {\n                nextNode = hydrateNode(nextNode, childVnode, renderer);\n                anchor = childVnode.elm;\n            }\n            else {\n                hasMismatch = true;\n                if (true) {\n                    if (!hasWarned) {\n                        hasWarned = true;\n                        logError(`Hydration mismatch: incorrect number of rendered nodes. Client produced more nodes than the server.`, owner);\n                    }\n                }\n                mount(childVnode, parentNode, renderer, anchor);\n                anchor = childVnode.elm;\n            }\n        }\n    }\n    if (nextNode) {\n        hasMismatch = true;\n        if (true) {\n            if (!hasWarned) {\n                logError(`Hydration mismatch: incorrect number of rendered nodes. Server rendered more nodes than the client.`, owner);\n            }\n        }\n        // nextSibling is mostly harmless, and since we don't have\n        // a good reference to what element to act upon, we instead\n        // rely on the vm's associated renderer for navigating to the\n        // next node in the list to be hydrated.\n        const { nextSibling } = renderer;\n        do {\n            const current = nextNode;\n            nextNode = nextSibling(nextNode);\n            removeNode(current, parentNode, renderer);\n        } while (nextNode);\n    }\n}\nfunction handleMismatch(node, vnode, renderer) {\n    hasMismatch = true;\n    const { getProperty } = renderer;\n    const parentNode = getProperty(node, 'parentNode');\n    mount(vnode, parentNode, renderer, node);\n    removeNode(node, parentNode, renderer);\n    return vnode.elm;\n}\nfunction patchElementPropsAndAttrs(vnode, renderer) {\n    applyEventListeners(vnode, renderer);\n    patchProps(null, vnode, renderer);\n}\nfunction hasCorrectNodeType(vnode, node, nodeType, renderer) {\n    const { getProperty } = renderer;\n    if (getProperty(node, 'nodeType') !== nodeType) {\n        if (true) {\n            logError('Hydration mismatch: incorrect node type received', vnode.owner);\n        }\n        return false;\n    }\n    return true;\n}\nfunction isMatchingElement(vnode, elm, renderer) {\n    const { getProperty } = renderer;\n    if (vnode.sel.toLowerCase() !== getProperty(elm, 'tagName').toLowerCase()) {\n        if (true) {\n            logError(`Hydration mismatch: expecting element with tag \"${vnode.sel.toLowerCase()}\" but found \"${getProperty(elm, 'tagName').toLowerCase()}\".`, vnode.owner);\n        }\n        return false;\n    }\n    const hasIncompatibleAttrs = validateAttrs(vnode, elm, renderer);\n    const hasIncompatibleClass = validateClassAttr(vnode, elm, renderer);\n    const hasIncompatibleStyle = validateStyleAttr(vnode, elm, renderer);\n    return hasIncompatibleAttrs && hasIncompatibleClass && hasIncompatibleStyle;\n}\nfunction attributeValuesAreEqual(vnodeValue, value) {\n    const vnodeValueAsString = String(vnodeValue);\n    if (vnodeValueAsString === value) {\n        return true;\n    }\n    // If the expected value is null, this means that the attribute does not exist. In that case,\n    // we accept any nullish value (undefined or null).\n    if (isNull(value) && (isUndefined$1(vnodeValue) || isNull(vnodeValue))) {\n        return true;\n    }\n    // In all other cases, the two values are not considered equal\n    return false;\n}\nfunction validateAttrs(vnode, elm, renderer) {\n    const { data: { attrs = {} }, } = vnode;\n    let nodesAreCompatible = true;\n    // Validate attributes, though we could always recovery from those by running the update mods.\n    // Note: intentionally ONLY matching vnodes.attrs to elm.attrs, in case SSR is adding extra attributes.\n    for (const [attrName, attrValue] of Object.entries(attrs)) {\n        const { owner } = vnode;\n        const { getAttribute } = renderer;\n        const elmAttrValue = getAttribute(elm, attrName);\n        if (!attributeValuesAreEqual(attrValue, elmAttrValue)) {\n            if (true) {\n                const { getProperty } = renderer;\n                logError(`Mismatch hydrating element <${getProperty(elm, 'tagName').toLowerCase()}>: attribute \"${attrName}\" has different values, expected \"${attrValue}\" but found ${isNull(elmAttrValue) ? 'null' : `\"${elmAttrValue}\"`}`, owner);\n            }\n            nodesAreCompatible = false;\n        }\n    }\n    return nodesAreCompatible;\n}\nfunction validateClassAttr(vnode, elm, renderer) {\n    const { data, owner } = vnode;\n    let { className, classMap } = data;\n    const { getProperty, getClassList } = renderer;\n    const scopedToken = getScopeTokenClass(owner);\n    const stylesheetTokenHost = isVCustomElement(vnode) ? getStylesheetTokenHost(vnode) : null;\n    // Classnames for scoped CSS are added directly to the DOM during rendering,\n    // or to the VDOM on the server in the case of SSR. As such, these classnames\n    // are never present in VDOM nodes in the browser.\n    //\n    // Consequently, hydration mismatches will occur if scoped CSS token classnames\n    // are rendered during SSR. This needs to be accounted for when validating.\n    if (!isNull(scopedToken) || !isNull(stylesheetTokenHost)) {\n        if (!isUndefined$1(className)) {\n            // The order of the className should be scopedToken className stylesheetTokenHost\n            const classTokens = [scopedToken, className, stylesheetTokenHost];\n            const classNames = ArrayFilter.call(classTokens, (token) => !isNull(token));\n            className = ArrayJoin.call(classNames, ' ');\n        }\n        else if (!isUndefined$1(classMap)) {\n            classMap = Object.assign(Object.assign(Object.assign({}, classMap), (!isNull(scopedToken) ? { [scopedToken]: true } : {})), (!isNull(stylesheetTokenHost) ? { [stylesheetTokenHost]: true } : {}));\n        }\n        else {\n            // The order of the className should be scopedToken stylesheetTokenHost\n            const classTokens = [scopedToken, stylesheetTokenHost];\n            const classNames = ArrayFilter.call(classTokens, (token) => !isNull(token));\n            if (classNames.length) {\n                className = ArrayJoin.call(classNames, ' ');\n            }\n        }\n    }\n    let nodesAreCompatible = true;\n    let readableVnodeClassname;\n    const elmClassName = getProperty(elm, 'className');\n    if (!isUndefined$1(className) && String(className) !== elmClassName) {\n        // className is used when class is bound to an expr.\n        nodesAreCompatible = false;\n        readableVnodeClassname = className;\n    }\n    else if (!isUndefined$1(classMap)) {\n        // classMap is used when class is set to static value.\n        const classList = getClassList(elm);\n        let computedClassName = '';\n        // all classes from the vnode should be in the element.classList\n        for (const name in classMap) {\n            computedClassName += ' ' + name;\n            if (!classList.contains(name)) {\n                nodesAreCompatible = false;\n            }\n        }\n        readableVnodeClassname = computedClassName.trim();\n        if (classList.length > keys(classMap).length) {\n            nodesAreCompatible = false;\n        }\n    }\n    else if (isUndefined$1(className) && elmClassName !== '') {\n        // SSR contains a className but client-side VDOM does not\n        nodesAreCompatible = false;\n        readableVnodeClassname = '';\n    }\n    if (!nodesAreCompatible) {\n        if (true) {\n            logError(`Mismatch hydrating element <${getProperty(elm, 'tagName').toLowerCase()}>: attribute \"class\" has different values, expected \"${readableVnodeClassname}\" but found \"${elmClassName}\"`, vnode.owner);\n        }\n    }\n    return nodesAreCompatible;\n}\nfunction validateStyleAttr(vnode, elm, renderer) {\n    const { data: { style, styleDecls }, } = vnode;\n    const { getAttribute } = renderer;\n    const elmStyle = getAttribute(elm, 'style') || '';\n    let vnodeStyle;\n    let nodesAreCompatible = true;\n    if (!isUndefined$1(style) && style !== elmStyle) {\n        nodesAreCompatible = false;\n        vnodeStyle = style;\n    }\n    else if (!isUndefined$1(styleDecls)) {\n        const parsedVnodeStyle = parseStyleText(elmStyle);\n        const expectedStyle = [];\n        // styleMap is used when style is set to static value.\n        for (let i = 0, n = styleDecls.length; i < n; i++) {\n            const [prop, value, important] = styleDecls[i];\n            expectedStyle.push(`${prop}: ${value + (important ? ' important!' : '')}`);\n            const parsedPropValue = parsedVnodeStyle[prop];\n            if (isUndefined$1(parsedPropValue)) {\n                nodesAreCompatible = false;\n            }\n            else if (!parsedPropValue.startsWith(value)) {\n                nodesAreCompatible = false;\n            }\n            else if (important && !parsedPropValue.endsWith('!important')) {\n                nodesAreCompatible = false;\n            }\n        }\n        if (keys(parsedVnodeStyle).length > styleDecls.length) {\n            nodesAreCompatible = false;\n        }\n        vnodeStyle = ArrayJoin.call(expectedStyle, ';');\n    }\n    if (!nodesAreCompatible) {\n        if (true) {\n            const { getProperty } = renderer;\n            logError(`Mismatch hydrating element <${getProperty(elm, 'tagName').toLowerCase()}>: attribute \"style\" has different values, expected \"${vnodeStyle}\" but found \"${elmStyle}\".`, vnode.owner);\n        }\n    }\n    return nodesAreCompatible;\n}\nfunction areCompatibleNodes(client, ssr, vnode, renderer) {\n    const { getProperty, getAttribute } = renderer;\n    if (getProperty(client, 'nodeType') === 3 /* EnvNodeTypes.TEXT */) {\n        if (!hasCorrectNodeType(vnode, ssr, 3 /* EnvNodeTypes.TEXT */, renderer)) {\n            return false;\n        }\n        return getProperty(client, NODE_VALUE_PROP) === getProperty(ssr, NODE_VALUE_PROP);\n    }\n    if (getProperty(client, 'nodeType') === 8 /* EnvNodeTypes.COMMENT */) {\n        if (!hasCorrectNodeType(vnode, ssr, 8 /* EnvNodeTypes.COMMENT */, renderer)) {\n            return false;\n        }\n        return getProperty(client, NODE_VALUE_PROP) === getProperty(ssr, NODE_VALUE_PROP);\n    }\n    if (!hasCorrectNodeType(vnode, ssr, 1 /* EnvNodeTypes.ELEMENT */, renderer)) {\n        return false;\n    }\n    let isCompatibleElements = true;\n    if (getProperty(client, 'tagName') !== getProperty(ssr, 'tagName')) {\n        if (true) {\n            logError(`Hydration mismatch: expecting element with tag \"${getProperty(client, 'tagName').toLowerCase()}\" but found \"${getProperty(ssr, 'tagName').toLowerCase()}\".`, vnode.owner);\n        }\n        return false;\n    }\n    const clientAttrsNames = getProperty(client, 'getAttributeNames').call(client);\n    clientAttrsNames.forEach((attrName) => {\n        if (getAttribute(client, attrName) !== getAttribute(ssr, attrName)) {\n            logError(`Mismatch hydrating element <${getProperty(client, 'tagName').toLowerCase()}>: attribute \"${attrName}\" has different values, expected \"${getAttribute(client, attrName)}\" but found \"${getAttribute(ssr, attrName)}\"`, vnode.owner);\n            isCompatibleElements = false;\n        }\n    });\n    return isCompatibleElements;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet hooksAreSet = false;\nfunction setHooks(hooks) {\n    assert.isFalse(hooksAreSet, 'Hooks are already overridden, only one definition is allowed.');\n    hooksAreSet = true;\n    setSanitizeHtmlContentHook(hooks.sanitizeHtmlContent);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// See @lwc/engine-core/src/framework/template.ts\nconst TEMPLATE_PROPS = ['slots', 'stylesheetToken', 'stylesheets', 'renderMode'];\n// Expandos that may be placed on a stylesheet factory function, and which are meaningful to LWC at runtime\nconst STYLESHEET_PROPS = [\n    // SEE `KEY__SCOPED_CSS` in @lwc/style-compiler\n    '$scoped$',\n];\n// Via https://www.npmjs.com/package/object-observer\nconst ARRAY_MUTATION_METHODS = [\n    'pop',\n    'push',\n    'shift',\n    'unshift',\n    'reverse',\n    'sort',\n    'fill',\n    'splice',\n    'copyWithin',\n];\nlet mutationTrackingDisabled = false;\nfunction getOriginalArrayMethod(prop) {\n    switch (prop) {\n        case 'pop':\n            return ArrayPop;\n        case 'push':\n            return ArrayPush$1;\n        case 'shift':\n            return ArrayShift;\n        case 'unshift':\n            return ArrayUnshift;\n        case 'reverse':\n            return ArrayReverse;\n        case 'sort':\n            return ArraySort;\n        case 'fill':\n            return ArrayFill;\n        case 'splice':\n            return ArraySplice;\n        case 'copyWithin':\n            return ArrayCopyWithin;\n    }\n}\nfunction reportViolation(type, eventId, prop) {\n    if (true) {\n        logWarnOnce(`Mutating the \"${prop}\" property on a ${type} ` +\n            `is deprecated and will be removed in a future version of LWC. ` +\n            `See: https://sfdc.co/template-mutation`);\n    }\n    report(eventId, { propertyName: prop });\n}\nfunction reportTemplateViolation(prop) {\n    reportViolation('template', \"TemplateMutation\" /* ReportingEventId.TemplateMutation */, prop);\n}\nfunction reportStylesheetViolation(prop) {\n    reportViolation('stylesheet', \"StylesheetMutation\" /* ReportingEventId.StylesheetMutation */, prop);\n}\n// Warn if the user tries to mutate a stylesheets array, e.g.:\n// `tmpl.stylesheets.push(someStylesheetFunction)`\nfunction warnOnArrayMutation(stylesheets) {\n    // We can't handle users calling Array.prototype.slice.call(tmpl.stylesheets), but\n    // we can at least warn when they use the most common mutation methods.\n    for (const prop of ARRAY_MUTATION_METHODS) {\n        const originalArrayMethod = getOriginalArrayMethod(prop);\n        stylesheets[prop] = function arrayMutationWarningWrapper() {\n            reportTemplateViolation('stylesheets');\n            // @ts-ignore\n            return originalArrayMethod.apply(this, arguments);\n        };\n    }\n}\n// Warn if the user tries to mutate a stylesheet factory function, e.g.:\n// `stylesheet.$scoped$ = true`\nfunction warnOnStylesheetFunctionMutation(stylesheet) {\n    for (const prop of STYLESHEET_PROPS) {\n        let value = stylesheet[prop];\n        defineProperty(stylesheet, prop, {\n            enumerable: true,\n            configurable: true,\n            get() {\n                return value;\n            },\n            set(newValue) {\n                reportStylesheetViolation(prop);\n                value = newValue;\n            },\n        });\n    }\n}\n// Warn on either array or stylesheet (function) mutation, in a deeply-nested array\nfunction trackStylesheetsMutation(stylesheets) {\n    traverseStylesheets(stylesheets, (subStylesheets) => {\n        if (isArray$1(subStylesheets)) {\n            warnOnArrayMutation(subStylesheets);\n        }\n        else {\n            warnOnStylesheetFunctionMutation(subStylesheets);\n        }\n    });\n}\n// Deeply freeze the entire array (of arrays) of stylesheet factory functions\nfunction deepFreeze(stylesheets) {\n    traverseStylesheets(stylesheets, (subStylesheets) => {\n        freeze(subStylesheets);\n    });\n}\n// Deep-traverse an array (of arrays) of stylesheet factory functions, and call the callback for every array/function\nfunction traverseStylesheets(stylesheets, callback) {\n    callback(stylesheets);\n    for (let i = 0; i < stylesheets.length; i++) {\n        const stylesheet = stylesheets[i];\n        if (isArray$1(stylesheet)) {\n            traverseStylesheets(stylesheet, callback);\n        }\n        else {\n            callback(stylesheet);\n        }\n    }\n}\nfunction trackMutations(tmpl) {\n    if (!isUndefined$1(tmpl.stylesheets)) {\n        trackStylesheetsMutation(tmpl.stylesheets);\n    }\n    for (const prop of TEMPLATE_PROPS) {\n        let value = tmpl[prop];\n        defineProperty(tmpl, prop, {\n            enumerable: true,\n            configurable: true,\n            get() {\n                return value;\n            },\n            set(newValue) {\n                if (!mutationTrackingDisabled) {\n                    reportTemplateViolation(prop);\n                }\n                value = newValue;\n            },\n        });\n    }\n    const originalDescriptor = getOwnPropertyDescriptor$1(tmpl, 'stylesheetTokens');\n    defineProperty(tmpl, 'stylesheetTokens', {\n        enumerable: true,\n        configurable: true,\n        get: originalDescriptor.get,\n        set(value) {\n            reportTemplateViolation('stylesheetTokens');\n            // Avoid logging/reporting twice (for both stylesheetToken and stylesheetTokens)\n            mutationTrackingDisabled = true;\n            originalDescriptor.set.call(this, value);\n            mutationTrackingDisabled = false;\n        },\n    });\n}\nfunction addLegacyStylesheetTokensShim(tmpl) {\n    // When ENABLE_FROZEN_TEMPLATE is false, then we shim stylesheetTokens on top of stylesheetToken for anyone who\n    // is accessing the old internal API (backwards compat). Details: https://salesforce.quip.com/v1rmAFu2cKAr\n    defineProperty(tmpl, 'stylesheetTokens', {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const { stylesheetToken } = this;\n            if (isUndefined$1(stylesheetToken)) {\n                return stylesheetToken;\n            }\n            // Shim for the old `stylesheetTokens` property\n            // See https://github.com/salesforce/lwc/pull/2332/files#diff-7901555acef29969adaa6583185b3e9bce475cdc6f23e799a54e0018cb18abaa\n            return {\n                hostAttribute: `${stylesheetToken}-host`,\n                shadowAttribute: stylesheetToken,\n            };\n        },\n        set(value) {\n            // If the value is null or some other exotic object, you would be broken anyway in the past\n            // because the engine would try to access hostAttribute/shadowAttribute, which would throw an error.\n            // However it may be undefined in newer versions of LWC, so we need to guard against that case.\n            this.stylesheetToken = isUndefined$1(value) ? undefined : value.shadowAttribute;\n        },\n    });\n}\nfunction freezeTemplate(tmpl) {\n    // TODO [#2782]: remove this flag and delete the legacy behavior\n    if (lwcRuntimeFlags.ENABLE_FROZEN_TEMPLATE) {\n        // Deep freeze the template\n        freeze(tmpl);\n        if (!isUndefined$1(tmpl.stylesheets)) {\n            deepFreeze(tmpl.stylesheets);\n        }\n    }\n    else {\n        // template is not frozen - shim, report, and warn\n        // this shim should be applied in both dev and prod\n        addLegacyStylesheetTokensShim(tmpl);\n        // When ENABLE_FROZEN_TEMPLATE is false, we want to warn in dev mode whenever someone is mutating the template\n        if (true) {\n            trackMutations(tmpl);\n        }\n        else {}\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function provides access to the component constructor, given an HTMLElement.\n * This API is subject to change or being removed.\n */\nfunction getComponentConstructor(elm) {\n    let ctor = null;\n    // intentionally checking for undefined due to some funky libraries patching weakmap.get\n    // to throw when undefined.\n    if (!isUndefined$1(elm)) {\n        const vm = getAssociatedVMIfPresent(elm);\n        if (!isUndefined$1(vm)) {\n            ctor = vm.def.ctor;\n        }\n    }\n    return ctor;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function allows you to create a reactive readonly\n * membrane around any object value. This API is subject to change or\n * being removed.\n */\nfunction readonly(obj) {\n    if (true) {\n        // TODO [#1292]: Remove the readonly decorator\n        if (arguments.length !== 1) {\n            assert.fail('@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.');\n        }\n    }\n    return getReadOnlyProxy(obj);\n}\n/* version: 2.38.0 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * Displays the header for a custom element.\n *\n * @param ce the custom element\n * @param componentInstance component instance associated with the custom element.\n */\nfunction getHeaderForCustomElement(ce, componentInstance) {\n    // [element]\n    // LWC component instance: [vm.component]\n    return [\n        'div',\n        {},\n        ['object', { object: ce, config: { skip: true } }],\n        [\n            'div',\n            {},\n            ['span', { style: 'margin: 0 5px; color: red' }, 'LWC:'],\n            ['object', { object: componentInstance }],\n        ],\n    ];\n}\nfunction getHeaderForComponentInstance(componentInstance, debugInfo) {\n    if (keys(debugInfo).length === 0) {\n        // there is no debug information, no need to customize this component instance\n        return null;\n    }\n    // [component]\n    // Debug information: [vm.debugInfo]\n    return [\n        'div',\n        {},\n        ['object', { object: componentInstance, config: { skip: true } }],\n        [\n            'div',\n            {},\n            ['span', { style: 'margin: 0 5px; color: red' }, 'Debug:'],\n            ['object', { object: debugInfo }],\n        ],\n    ];\n}\nconst LightningElementFormatter = {\n    name: 'LightningElementFormatter',\n    header(obj, config) {\n        const vm = getAssociatedVMIfPresent(obj);\n        if (!isUndefined$1(vm) && (isUndefined$1(config) || !config.skip)) {\n            if (obj instanceof HTMLElement) {\n                return getHeaderForCustomElement(obj, vm.component);\n            }\n            else {\n                return getHeaderForComponentInstance(obj, vm.debugInfo);\n            }\n        }\n        return null;\n    },\n    hasBody() {\n        return false;\n    },\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction init() {\n    const devtoolsFormatters = _globalThis.devtoolsFormatters || [];\n    ArrayPush$1.call(devtoolsFormatters, LightningElementFormatter);\n    _globalThis.devtoolsFormatters = devtoolsFormatters;\n}\nif (true) {\n    init();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n//\n// Feature detection\n//\n// This check for constructable style sheets is similar to Fast's:\n// https://github.com/microsoft/fast/blob/d49d1ec/packages/web-components/fast-element/src/dom.ts#L51-L53\n// See also: https://github.com/whatwg/webidl/issues/1027#issuecomment-934510070\nconst supportsConstructableStylesheets = isFunction$1(CSSStyleSheet.prototype.replaceSync) && isArray$1(document.adoptedStyleSheets);\n// The original adoptedStylesheet proposal used a frozen array. A follow-up proposal made the array mutable.\n// Chromium 99+ and Firefox 101+ support mutable arrays. We check if the array is mutable, to ensure backward compat.\n// (If the length is writable, then the array is mutable.) See: https://chromestatus.com/feature/5638996492288000\n// TODO [#2828]: Re-evaluate this in the future once we drop support for older browser versions.\nconst supportsMutableAdoptedStyleSheets = supportsConstructableStylesheets &&\n    getOwnPropertyDescriptor$1(document.adoptedStyleSheets, 'length').writable;\n// Detect IE, via https://stackoverflow.com/a/9851769\nconst isIE11 = !isUndefined$1(document.documentMode);\nconst stylesheetCache = new Map();\n//\n// Test utilities\n//\n// Only used in LWC's Karma tests\nif (false) {}\nfunction createFreshStyleElement(content) {\n    const elm = document.createElement('style');\n    elm.type = 'text/css';\n    elm.textContent = content;\n    return elm;\n}\nfunction createStyleElement(content, cacheData) {\n    const { element, usedElement } = cacheData;\n    // If the <style> was already used, then we should clone it. We cannot insert\n    // the same <style> in two places in the DOM.\n    if (usedElement) {\n        // For a mysterious reason, IE11 doesn't like the way we clone <style> nodes\n        // and will render the incorrect styles if we do things that way. It's just\n        // a perf optimization, so we can skip it for IE11.\n        if (isIE11) {\n            return createFreshStyleElement(content);\n        }\n        // This `<style>` may be repeated multiple times in the DOM, so cache it. It's a bit\n        // faster to call `cloneNode()` on an existing node than to recreate it every time.\n        return element.cloneNode(true);\n    }\n    // We don't clone every time, because that would be a perf tax on the first time\n    cacheData.usedElement = true;\n    return element;\n}\nfunction createConstructableStylesheet(content) {\n    const stylesheet = new CSSStyleSheet();\n    stylesheet.replaceSync(content);\n    return stylesheet;\n}\nfunction insertConstructableStylesheet(content, target, cacheData) {\n    const { adoptedStyleSheets } = target;\n    const { stylesheet } = cacheData;\n    // Mutable adopted stylesheets are only supported in certain browsers.\n    // The reason we use it is for perf: https://github.com/salesforce/lwc/pull/2683\n    if (supportsMutableAdoptedStyleSheets) {\n        adoptedStyleSheets.push(stylesheet);\n    }\n    else {\n        target.adoptedStyleSheets = [...adoptedStyleSheets, stylesheet];\n    }\n}\nfunction insertStyleElement(content, target, cacheData) {\n    const elm = createStyleElement(content, cacheData);\n    target.appendChild(elm);\n}\nfunction getCacheData(content, useConstructableStylesheet) {\n    let cacheData = stylesheetCache.get(content);\n    if (isUndefined$1(cacheData)) {\n        cacheData = {\n            stylesheet: undefined,\n            element: undefined,\n            roots: undefined,\n            global: false,\n            usedElement: false,\n        };\n        stylesheetCache.set(content, cacheData);\n    }\n    // Create <style> elements or CSSStyleSheets on-demand, as needed\n    if (useConstructableStylesheet && isUndefined$1(cacheData.stylesheet)) {\n        cacheData.stylesheet = createConstructableStylesheet(content);\n    }\n    else if (!useConstructableStylesheet && isUndefined$1(cacheData.element)) {\n        cacheData.element = createFreshStyleElement(content);\n    }\n    return cacheData;\n}\nfunction insertGlobalStylesheet(content) {\n    // Force a <style> element for global stylesheets. See comment below.\n    const cacheData = getCacheData(content, false);\n    if (cacheData.global) {\n        // already inserted\n        return;\n    }\n    cacheData.global = true; // mark inserted\n    // TODO [#2922]: use document.adoptedStyleSheets in supported browsers. Currently we can't, due to backwards compat.\n    insertStyleElement(content, document.head, cacheData);\n}\nfunction insertLocalStylesheet(content, target) {\n    const cacheData = getCacheData(content, supportsConstructableStylesheets);\n    let { roots } = cacheData;\n    if (isUndefined$1(roots)) {\n        roots = cacheData.roots = new WeakSet(); // lazily initialize (not needed for global styles)\n    }\n    else if (roots.has(target)) {\n        // already inserted\n        return;\n    }\n    roots.add(target); // mark inserted\n    // Constructable stylesheets are only supported in certain browsers:\n    // https://caniuse.com/mdn-api_document_adoptedstylesheets\n    // The reason we use it is for perf: https://github.com/salesforce/lwc/pull/2460\n    if (supportsConstructableStylesheets) {\n        insertConstructableStylesheet(content, target, cacheData);\n    }\n    else {\n        // Fall back to <style> element\n        insertStyleElement(content, target, cacheData);\n    }\n}\nfunction insertStylesheet(content, target) {\n    if (isUndefined$1(target)) {\n        // global\n        insertGlobalStylesheet(content);\n    }\n    else {\n        // local\n        insertLocalStylesheet(content, target);\n    }\n}\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction isCustomElementRegistryAvailable() {\n    if (typeof customElements === 'undefined') {\n        return false;\n    }\n    try {\n        // dereference HTMLElement global because babel wraps globals in compat mode with a\n        // _wrapNativeSuper()\n        // This is a problem because LWCUpgradableElement extends renderer.HTMLElement which does not\n        // get wrapped by babel.\n        const HTMLElementAlias = HTMLElement;\n        // In case we use compat mode with a modern browser, the compat mode transformation\n        // invokes the DOM api with an .apply() or .call() to initialize any DOM api sub-classing,\n        // which are not equipped to be initialized that way.\n        class clazz extends HTMLElementAlias {\n        }\n        customElements.define('lwc-test-' + Math.floor(Math.random() * 1000000), clazz);\n        new clazz();\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nconst hasCustomElements = isCustomElementRegistryAvailable();\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Creates a custom element for compat (legacy) browser environments\nconst createCustomElementCompat = (tagName, upgradeCallback) => {\n    const elm = document.createElement(tagName);\n    upgradeCallback(elm); // nothing to do with the result for now\n    return elm;\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst cachedConstructors = new Map();\nconst elementsUpgradedOutsideLWC = new WeakSet();\nlet elementBeingUpgradedByLWC = false;\n// Creates a constructor that is intended to be used directly as a custom element, except that the upgradeCallback is\n// passed in to the constructor so LWC can reuse the same custom element constructor for multiple components.\n// Another benefit is that only LWC can create components that actually do anything  if you do\n// `customElements.define('x-foo')`, then you don't have access to the upgradeCallback, so it's a dummy custom element.\n// This class should be created once per tag name.\nconst createUpgradableConstructor = (connectedCallback, disconnectedCallback) => {\n    const hasConnectedCallback = !isUndefined$1(connectedCallback);\n    const hasDisconnectedCallback = !isUndefined$1(disconnectedCallback);\n    // TODO [#2972]: this class should expose observedAttributes as necessary\n    class UpgradableConstructor extends HTMLElement {\n        constructor(upgradeCallback) {\n            super();\n            // If the element is not created using lwc.createElement(), e.g. `document.createElement('x-foo')`,\n            // then elementBeingUpgraded will be false\n            if (elementBeingUpgradedByLWC) {\n                upgradeCallback(this);\n            }\n            else if (hasConnectedCallback || hasDisconnectedCallback) {\n                // If this element has connected or disconnected callbacks, then we need to keep track of\n                // instances that were created outside LWC (i.e. not created by `lwc.createElement()`).\n                // If the element has no connected or disconnected callbacks, then we don't need to track this.\n                elementsUpgradedOutsideLWC.add(this);\n                // TODO [#2970]: LWC elements cannot be upgraded via new Ctor()\n                // Do we want to support this? Throw an error? Currently for backwards compat it's a no-op.\n            }\n        }\n    }\n    // Do not unnecessarily add a connectedCallback/disconnectedCallback, as it introduces perf overhead\n    // See: https://github.com/salesforce/lwc/pull/3162#issuecomment-1311851174\n    if (hasConnectedCallback) {\n        UpgradableConstructor.prototype.connectedCallback = function () {\n            if (!elementsUpgradedOutsideLWC.has(this)) {\n                connectedCallback(this);\n            }\n        };\n    }\n    if (hasDisconnectedCallback) {\n        UpgradableConstructor.prototype.disconnectedCallback = function () {\n            if (!elementsUpgradedOutsideLWC.has(this)) {\n                disconnectedCallback(this);\n            }\n        };\n    }\n    return UpgradableConstructor;\n};\nconst createCustomElementUsingUpgradableConstructor = (tagName, upgradeCallback, connectedCallback, disconnectedCallback) => {\n    // use global custom elements registry\n    let UpgradableConstructor = cachedConstructors.get(tagName);\n    if (isUndefined$1(UpgradableConstructor)) {\n        if (!isUndefined$1(customElements.get(tagName))) {\n            throw new Error(`Unexpected tag name \"${tagName}\". This name is a registered custom element, preventing LWC to upgrade the element.`);\n        }\n        UpgradableConstructor = createUpgradableConstructor(connectedCallback, disconnectedCallback);\n        customElements.define(tagName, UpgradableConstructor);\n        cachedConstructors.set(tagName, UpgradableConstructor);\n    }\n    elementBeingUpgradedByLWC = true;\n    try {\n        return new UpgradableConstructor(upgradeCallback);\n    }\n    finally {\n        elementBeingUpgradedByLWC = false;\n    }\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * We have two modes for creating custom elements:\n *\n * 1. Compat (legacy) browser support (e.g. IE11). Totally custom, doesn't rely on native browser APIs.\n * 2. \"Upgradable constructor\" custom element. This allows us to have two LWC components with the same tag name,\n *    via a trick: every custom element constructor we define in the registry is basically the same. It's essentially\n *    a dummy `class extends HTMLElement` that accepts an `upgradeCallback` in its constructor (\"upgradable\n *    constructor\"), which allows us to have completely customized functionality for different components.\n */\nlet createCustomElement;\nif (hasCustomElements) {\n    // use the global registry, with an upgradable constructor for the defined custom element\n    createCustomElement = createCustomElementUsingUpgradableConstructor;\n}\nelse {\n    // no registry available here\n    createCustomElement = createCustomElementCompat;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * A factory function that produces a renderer.\n * Renderer encapsulates operations that are required to render an LWC component into the underlying\n * runtime environment. In the case of @lwc/enigne-dom, it is meant to be used in a DOM environment.\n * Example usage:\n * import { renderer, rendererFactory } from 'lwc';\n * const customRenderer = rendererFactory(renderer);\n *\n * @param baseRenderer Either null or the base renderer imported from 'lwc'.\n */\nfunction rendererFactory(baseRenderer) {\n    const renderer = (function (exports) {\n\n    /**\n     * Copyright (C) 2018 salesforce.com, inc.\n     */\n    /*\n     * Copyright (c) 2018, salesforce.com, inc.\n     * All rights reserved.\n     * SPDX-License-Identifier: MIT\n     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n     */\n    function invariant(value, msg) {\n        if (!value) {\n            throw new Error(`Invariant Violation: ${msg}`);\n        }\n    }\n    function isTrue$1(value, msg) {\n        if (!value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    }\n    function isFalse$1(value, msg) {\n        if (value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    }\n    function fail(msg) {\n        throw new Error(msg);\n    }\n\n    var assert = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        fail: fail,\n        invariant: invariant,\n        isFalse: isFalse$1,\n        isTrue: isTrue$1\n    });\n    function isUndefined(obj) {\n        return obj === undefined;\n    }\n    function isNull(obj) {\n        return obj === null;\n    }\n    /** version: 2.38.0 */\n\n    /*\n     * Copyright (c) 2023, salesforce.com, inc.\n     * All rights reserved.\n     * SPDX-License-Identifier: MIT\n     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n     */\n    class WireContextSubscriptionEvent extends CustomEvent {\n        constructor(adapterToken, { setNewContext, setDisconnectedCallback }) {\n            super(adapterToken, {\n                bubbles: true,\n                composed: true,\n            });\n            this.setNewContext = setNewContext;\n            this.setDisconnectedCallback = setDisconnectedCallback;\n        }\n    }\n    function registerContextConsumer(elm, adapterContextToken, subscriptionPayload) {\n        dispatchEvent(elm, new WireContextSubscriptionEvent(adapterContextToken, subscriptionPayload));\n    }\n    function registerContextProvider(elm, adapterContextToken, onContextSubscription) {\n        addEventListener(elm, adapterContextToken, ((evt) => {\n            evt.stopImmediatePropagation();\n            const { setNewContext, setDisconnectedCallback } = evt;\n            onContextSubscription({\n                setNewContext,\n                setDisconnectedCallback,\n            });\n        }));\n    }\n\n    /*\n     * Copyright (c) 2018, salesforce.com, inc.\n     * All rights reserved.\n     * SPDX-License-Identifier: MIT\n     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n     */\n    function cloneNode(node, deep) {\n        return node.cloneNode(deep);\n    }\n    function createElement(tagName, namespace) {\n        return isUndefined(namespace)\n            ? document.createElement(tagName)\n            : document.createElementNS(namespace, tagName);\n    }\n    function createText(content) {\n        return document.createTextNode(content);\n    }\n    function createComment(content) {\n        return document.createComment(content);\n    }\n    exports.createFragment = void 0;\n    // IE11 lacks support for this feature\n    const SUPPORTS_TEMPLATE = typeof HTMLTemplateElement === 'function';\n    if (SUPPORTS_TEMPLATE) {\n        // Parse the fragment HTML string into DOM\n        exports.createFragment = function (html) {\n            const template = document.createElement('template');\n            template.innerHTML = html;\n            return template.content.firstChild;\n        };\n    }\n    else {\n        // In browsers that don't support <template> (e.g. IE11), we need to be careful to wrap elements like\n        // <td> in the proper container elements (e.g. <tbody>), because otherwise they will be parsed as null.\n        // Via https://github.com/webcomponents/polyfills/blob/ee1db33/packages/template/template.js#L273-L280\n        // With other elements added from:\n        // https://github.com/sindresorhus/html-tags/blob/95dcdd5/index.js\n        // Using the test:\n        // document.createRange().createContextualFragment(`<${tag}></${tag}>`).firstChild === null\n        // And omitting <html>, <head>, and <body> as these are not practical in an LWC component.\n        const topLevelWrappingMap = {\n            caption: ['table'],\n            col: ['colgroup', 'table'],\n            colgroup: ['table'],\n            option: ['select'],\n            tbody: ['table'],\n            td: ['tr', 'tbody', 'table'],\n            th: ['tr', 'tbody', 'table'],\n            thead: ['table'],\n            tfoot: ['table'],\n            tr: ['tbody', 'table'],\n        };\n        // Via https://github.com/webcomponents/polyfills/blob/ee1db33/packages/template/template.js#L282-L288\n        const getTagName = function (text) {\n            return (/<([a-z][^/\\0>\\x20\\t\\r\\n\\f]+)/i.exec(text) || ['', ''])[1].toLowerCase();\n        };\n        // Via https://github.com/webcomponents/polyfills/blob/ee1db33/packages/template/template.js#L295-L320\n        exports.createFragment = function (html) {\n            const wrapperTags = topLevelWrappingMap[getTagName(html)];\n            if (!isUndefined(wrapperTags)) {\n                for (const wrapperTag of wrapperTags) {\n                    html = `<${wrapperTag}>${html}</${wrapperTag}>`;\n                }\n            }\n            // For IE11, the document title must not be undefined, but it can be an empty string\n            // https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createHTMLDocument#browser_compatibility\n            const doc = document.implementation.createHTMLDocument('');\n            doc.body.innerHTML = html;\n            let content = doc.body;\n            if (!isUndefined(wrapperTags)) {\n                for (let i = 0; i < wrapperTags.length; i++) {\n                    content = content.firstChild;\n                }\n            }\n            return content.firstChild;\n        };\n    }\n    function insert(node, parent, anchor) {\n        parent.insertBefore(node, anchor);\n    }\n    function remove(node, parent) {\n        parent.removeChild(node);\n    }\n    function nextSibling(node) {\n        return node.nextSibling;\n    }\n    function attachShadow(element, options) {\n        // `shadowRoot` will be non-null in two cases:\n        //   1. upon initial load with an SSR-generated DOM, while in Shadow render mode\n        //   2. when a webapp author places <c-app> in their static HTML and mounts their\n        //      root component with customElement.define('c-app', Ctor)\n        if (!isNull(element.shadowRoot)) {\n            return element.shadowRoot;\n        }\n        return element.attachShadow(options);\n    }\n    function setText(node, content) {\n        node.nodeValue = content;\n    }\n    function getProperty(node, key) {\n        return node[key];\n    }\n    function setProperty(node, key, value) {\n        node[key] = value;\n    }\n    function getAttribute(element, name, namespace) {\n        return isUndefined(namespace)\n            ? element.getAttribute(name)\n            : element.getAttributeNS(namespace, name);\n    }\n    function setAttribute(element, name, value, namespace) {\n        return isUndefined(namespace)\n            ? element.setAttribute(name, value)\n            : element.setAttributeNS(namespace, name, value);\n    }\n    function removeAttribute(element, name, namespace) {\n        if (isUndefined(namespace)) {\n            element.removeAttribute(name);\n        }\n        else {\n            element.removeAttributeNS(namespace, name);\n        }\n    }\n    function addEventListener(target, type, callback, options) {\n        target.addEventListener(type, callback, options);\n    }\n    function removeEventListener(target, type, callback, options) {\n        target.removeEventListener(type, callback, options);\n    }\n    function dispatchEvent(target, event) {\n        return target.dispatchEvent(event);\n    }\n    function getClassList(element) {\n        return element.classList;\n    }\n    function setCSSStyleProperty(element, name, value, important) {\n        // TODO [#0]: How to avoid this type casting? Shall we use a different type interface to\n        // represent elements in the engine?\n        element.style.setProperty(name, value, important ? 'important' : '');\n    }\n    function getBoundingClientRect(element) {\n        return element.getBoundingClientRect();\n    }\n    function querySelector(element, selectors) {\n        return element.querySelector(selectors);\n    }\n    function querySelectorAll(element, selectors) {\n        return element.querySelectorAll(selectors);\n    }\n    function getElementsByTagName(element, tagNameOrWildCard) {\n        return element.getElementsByTagName(tagNameOrWildCard);\n    }\n    function getElementsByClassName(element, names) {\n        return element.getElementsByClassName(names);\n    }\n    function getChildren(element) {\n        return element.children;\n    }\n    function getChildNodes(element) {\n        return element.childNodes;\n    }\n    function getFirstChild(element) {\n        return element.firstChild;\n    }\n    function getFirstElementChild(element) {\n        return element.firstElementChild;\n    }\n    function getLastChild(element) {\n        return element.lastChild;\n    }\n    function getLastElementChild(element) {\n        return element.lastElementChild;\n    }\n    function isConnected(node) {\n        return node.isConnected;\n    }\n    function assertInstanceOfHTMLElement(elm, msg) {\n        assert.invariant(elm instanceof HTMLElement, msg);\n    }\n    function ownerDocument(element) {\n        return element.ownerDocument;\n    }\n\n    exports.addEventListener = addEventListener;\n    exports.assertInstanceOfHTMLElement = assertInstanceOfHTMLElement;\n    exports.attachShadow = attachShadow;\n    exports.cloneNode = cloneNode;\n    exports.createComment = createComment;\n    exports.createElement = createElement;\n    exports.createText = createText;\n    exports.dispatchEvent = dispatchEvent;\n    exports.getAttribute = getAttribute;\n    exports.getBoundingClientRect = getBoundingClientRect;\n    exports.getChildNodes = getChildNodes;\n    exports.getChildren = getChildren;\n    exports.getClassList = getClassList;\n    exports.getElementsByClassName = getElementsByClassName;\n    exports.getElementsByTagName = getElementsByTagName;\n    exports.getFirstChild = getFirstChild;\n    exports.getFirstElementChild = getFirstElementChild;\n    exports.getLastChild = getLastChild;\n    exports.getLastElementChild = getLastElementChild;\n    exports.getProperty = getProperty;\n    exports.insert = insert;\n    exports.isConnected = isConnected;\n    exports.nextSibling = nextSibling;\n    exports.ownerDocument = ownerDocument;\n    exports.querySelector = querySelector;\n    exports.querySelectorAll = querySelectorAll;\n    exports.registerContextConsumer = registerContextConsumer;\n    exports.registerContextProvider = registerContextProvider;\n    exports.remove = remove;\n    exports.removeAttribute = removeAttribute;\n    exports.removeEventListener = removeEventListener;\n    exports.setAttribute = setAttribute;\n    exports.setCSSStyleProperty = setCSSStyleProperty;\n    exports.setProperty = setProperty;\n    exports.setText = setText;\n\n    return exports;\n\n})({});\n    // Meant to inherit any properties passed via the base renderer as the argument to the factory.\n    Object.setPrototypeOf(renderer, baseRenderer);\n    return renderer;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * The base renderer that will be used by engine-core.\n * This will be used for DOM operations when lwc is running in a browser environment.\n */\nconst renderer = assign(\n// The base renderer will invoke the factory with null and assign additional properties that are\n// shared across renderers\nrendererFactory(null), \n// Properties that are either not required to be sandboxed or rely on a globally shared information\n{\n    // insertStyleSheet implementation shares a global cache of stylesheet data\n    insertStylesheet,\n    // relies on a shared global cache\n    createCustomElement,\n    isNativeShadowDefined: _globalThis[KEY__IS_NATIVE_SHADOW_ROOT_DEFINED],\n    isSyntheticShadowDefined: hasOwnProperty$1.call(Element.prototype, KEY__SHADOW_TOKEN),\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction resetShadowRootAndLightDom(element, Ctor) {\n    if (element.shadowRoot) {\n        const shadowRoot = element.shadowRoot;\n        while (!isNull(shadowRoot.firstChild)) {\n            shadowRoot.removeChild(shadowRoot.firstChild);\n        }\n    }\n    if (Ctor.renderMode === 'light') {\n        while (!isNull(element.firstChild)) {\n            element.removeChild(element.firstChild);\n        }\n    }\n}\nfunction createVMWithProps(element, Ctor, props) {\n    const vm = createVM(element, Ctor, renderer, {\n        mode: 'open',\n        owner: null,\n        tagName: element.tagName.toLowerCase(),\n        hydrated: true,\n    });\n    for (const [key, value] of Object.entries(props)) {\n        element[key] = value;\n    }\n    return vm;\n}\nfunction hydrateComponent(element, Ctor, props = {}) {\n    if (!(element instanceof Element)) {\n        throw new TypeError(`\"hydrateComponent\" expects a valid DOM element as the first parameter but instead received ${element}.`);\n    }\n    if (!isFunction$1(Ctor)) {\n        throw new TypeError(`\"hydrateComponent\" expects a valid component constructor as the second parameter but instead received ${Ctor}.`);\n    }\n    if (!isObject(props) || isNull(props)) {\n        throw new TypeError(`\"hydrateComponent\" expects an object as the third parameter but instead received ${props}.`);\n    }\n    if (getAssociatedVMIfPresent(element)) {\n        /* eslint-disable-next-line no-console */\n        console.warn(`\"hydrateComponent\" expects an element that is not hydrated.`, element);\n        return;\n    }\n    try {\n        const vm = createVMWithProps(element, Ctor, props);\n        hydrateRoot(vm);\n    }\n    catch (e) {\n        // Fallback: In case there's an error while hydrating, let's log the error, and replace the element content\n        //           with the client generated DOM.\n        /* eslint-disable-next-line no-console */\n        console.error('Recovering from error while hydrating: ', e);\n        // We want to preserve the element, so we need to reset the shadowRoot and light dom.\n        resetShadowRootAndLightDom(element, Ctor);\n        // we need to recreate the vm with the hydration flag on, so it re-uses the existing shadowRoot.\n        createVMWithProps(element, Ctor, props);\n        connectRootElement(element);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This function builds a Web Component class from a LWC constructor so it can be\n * registered as a new element via customElements.define() at any given time.\n *\n * @deprecated since version 1.3.11\n *\n * @example\n * ```\n * import { buildCustomElementConstructor } from 'lwc';\n * import Foo from 'ns/foo';\n * const WC = buildCustomElementConstructor(Foo);\n * customElements.define('x-foo', WC);\n * const elm = document.createElement('x-foo');\n * ```\n */\nfunction deprecatedBuildCustomElementConstructor(Ctor) {\n    if (true) {\n        /* eslint-disable-next-line no-console */\n        console.warn('Deprecated function called: \"buildCustomElementConstructor\" function is deprecated and it will be removed.' +\n            `Use \"${Ctor.name}.CustomElementConstructor\" static property of the component constructor to access the corresponding custom element constructor instead.`);\n    }\n    return Ctor.CustomElementConstructor;\n}\n// Note: WeakSet is not supported in IE11, and the polyfill is not performant enough.\n//       This WeakSet usage is valid because this functionality is not meant to run in IE11.\nconst hydratedCustomElements = new WeakSet();\nfunction buildCustomElementConstructor(Ctor) {\n    var _a;\n    const HtmlPrototype = getComponentHtmlPrototype(Ctor);\n    const { observedAttributes } = HtmlPrototype;\n    const { attributeChangedCallback } = HtmlPrototype.prototype;\n    return _a = class extends HTMLElement {\n            constructor() {\n                super();\n                if (this.isConnected) {\n                    // this if block is hit when there's already an un-upgraded element in the DOM with the same tag name.\n                    hydrateComponent(this, Ctor, {});\n                    hydratedCustomElements.add(this);\n                }\n                else {\n                    createVM(this, Ctor, renderer, {\n                        mode: 'open',\n                        owner: null,\n                        tagName: this.tagName,\n                    });\n                }\n            }\n            connectedCallback() {\n                if (hydratedCustomElements.has(this)) {\n                    // This is an un-upgraded element that was hydrated in the constructor.\n                    hydratedCustomElements.delete(this);\n                }\n                else {\n                    connectRootElement(this);\n                }\n            }\n            disconnectedCallback() {\n                disconnectRootElement(this);\n            }\n            attributeChangedCallback(name, oldValue, newValue) {\n                attributeChangedCallback.call(this, name, oldValue, newValue);\n            }\n        },\n        _a.observedAttributes = observedAttributes,\n        _a;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// TODO [#2472]: Remove this workaround when appropriate.\n// eslint-disable-next-line @lwc/lwc-internal/no-global-node\nconst _Node$1 = Node;\nconst ConnectingSlot = new WeakMap();\nconst DisconnectingSlot = new WeakMap();\nfunction callNodeSlot(node, slot) {\n    if (true) {\n        assert.isTrue(node, `callNodeSlot() should not be called for a non-object`);\n    }\n    const fn = slot.get(node);\n    if (!isUndefined$1(fn)) {\n        fn(node);\n    }\n    return node; // for convenience\n}\nif (!lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {\n    // Monkey patching Node methods to be able to detect the insertions and removal of root elements\n    // created via createElement.\n    const { appendChild, insertBefore, removeChild, replaceChild } = _Node$1.prototype;\n    assign(_Node$1.prototype, {\n        appendChild(newChild) {\n            const appendedNode = appendChild.call(this, newChild);\n            return callNodeSlot(appendedNode, ConnectingSlot);\n        },\n        insertBefore(newChild, referenceNode) {\n            const insertedNode = insertBefore.call(this, newChild, referenceNode);\n            return callNodeSlot(insertedNode, ConnectingSlot);\n        },\n        removeChild(oldChild) {\n            const removedNode = removeChild.call(this, oldChild);\n            return callNodeSlot(removedNode, DisconnectingSlot);\n        },\n        replaceChild(newChild, oldChild) {\n            const replacedNode = replaceChild.call(this, newChild, oldChild);\n            callNodeSlot(replacedNode, DisconnectingSlot);\n            callNodeSlot(newChild, ConnectingSlot);\n            return replacedNode;\n        },\n    });\n}\n/**\n * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly\n * difference that in the options, you can pass the `is` property set to a Constructor instead of\n * just a string value. The intent is to allow the creation of an element controlled by LWC without\n * having to register the element as a custom element.\n *\n * @example\n * ```\n * const el = createElement('x-foo', { is: FooCtor });\n * ```\n */\nfunction createElement(sel, options) {\n    if (!isObject(options) || isNull(options)) {\n        throw new TypeError(`\"createElement\" function expects an object as second parameter but received \"${toString$1(options)}\".`);\n    }\n    const Ctor = options.is;\n    if (!isFunction$1(Ctor)) {\n        throw new TypeError(`\"createElement\" function expects an \"is\" option with a valid component constructor.`);\n    }\n    const { createCustomElement } = renderer;\n    // tagName must be all lowercase, unfortunately, we have legacy code that is\n    // passing `sel` as a camel-case, which makes them invalid custom elements name\n    // the following line guarantees that this does not leaks beyond this point.\n    const tagName = StringToLowerCase.call(sel);\n    // the custom element from the registry is expecting an upgrade callback\n    /**\n     * Note: if the upgradable constructor does not expect, or throw when we new it\n     * with a callback as the first argument, we could implement a more advanced\n     * mechanism that only passes that argument if the constructor is known to be\n     * an upgradable custom element.\n     */\n    const upgradeCallback = (elm) => {\n        createVM(elm, Ctor, renderer, {\n            tagName,\n            mode: options.mode !== 'closed' ? 'open' : 'closed',\n            owner: null,\n        });\n        if (!lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {\n            ConnectingSlot.set(elm, connectRootElement);\n            DisconnectingSlot.set(elm, disconnectRootElement);\n        }\n    };\n    let connectedCallback;\n    let disconnectedCallback;\n    if (lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {\n        connectedCallback = (elm) => {\n            connectRootElement(elm);\n        };\n        disconnectedCallback = (elm) => {\n            disconnectRootElement(elm);\n        };\n    }\n    const element = createCustomElement(tagName, upgradeCallback, connectedCallback, disconnectedCallback);\n    return element;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// TODO [#2472]: Remove this workaround when appropriate.\n// eslint-disable-next-line @lwc/lwc-internal/no-global-node\nconst _Node = Node;\n/**\n * EXPERIMENTAL: The purpose of this function is to detect shadowed nodes. THIS API WILL BE REMOVED\n * ONCE LOCKER V1 IS NO LONGER SUPPORTED.\n */\nfunction isNodeShadowed(node) {\n    if (isFalse(node instanceof _Node)) {\n        return false;\n    }\n    // It's debatable whether shadow root instances should be considered as shadowed, but we keep\n    // this unchanged for legacy reasons (#1250).\n    if (node instanceof ShadowRoot) {\n        return false;\n    }\n    const rootNode = node.getRootNode();\n    // Handle the native case. We can return early here because an invariant of LWC is that\n    // synthetic roots cannot be descendants of native roots.\n    if (rootNode instanceof ShadowRoot &&\n        isFalse(hasOwnProperty$1.call(getPrototypeOf$1(rootNode), 'synthetic'))) {\n        return true;\n    }\n    // TODO [#1252]: Old behavior that is still used by some pieces of the platform. Manually\n    // inserted nodes without the `lwc:dom=manual` directive will be considered as global elements.\n    return renderer.isSyntheticShadowDefined && !isUndefined$1(node[KEY__SHADOW_RESOLVER]);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ComponentConstructorToCustomElementConstructorMap = new Map();\nfunction getCustomElementConstructor(Ctor) {\n    if (Ctor === LightningElement) {\n        throw new TypeError(`Invalid Constructor. LightningElement base class can't be claimed as a custom element.`);\n    }\n    let ce = ComponentConstructorToCustomElementConstructorMap.get(Ctor);\n    if (isUndefined$1(ce)) {\n        ce = buildCustomElementConstructor(Ctor);\n        ComponentConstructorToCustomElementConstructorMap.set(Ctor, ce);\n    }\n    return ce;\n}\n/**\n * This static getter builds a Web Component class from a LWC constructor so it can be registered\n * as a new element via customElements.define() at any given time. E.g.:\n *\n *      import Foo from 'ns/foo';\n *      customElements.define('x-foo', Foo.CustomElementConstructor);\n *      const elm = document.createElement('x-foo');\n *\n */\ndefineProperty(LightningElement, 'CustomElementConstructor', {\n    get() {\n        return getCustomElementConstructor(this);\n    },\n});\nfreeze(LightningElement);\nseal(LightningElement.prototype);\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction addEventListener(target, type, callback, options) {\n    target.addEventListener(type, callback, options);\n}\n\n/*\n * Copyright (c) 2023, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction createContextProvider(adapter) {\n    return createContextProviderWithRegister(adapter, registerContextProvider);\n}\nfunction registerContextProvider(elm, adapterContextToken, onContextSubscription) {\n    addEventListener(elm, adapterContextToken, ((evt) => {\n        evt.stopImmediatePropagation();\n        const { setNewContext, setDisconnectedCallback } = evt;\n        onContextSubscription({\n            setNewContext,\n            setDisconnectedCallback,\n        });\n    }));\n}\n\nexports.LightningElement = LightningElement;\nexports.__unstable__ProfilerControl = profilerControl;\nexports.__unstable__ReportingControl = reportingControl;\nexports.api = api$1;\nexports.buildCustomElementConstructor = deprecatedBuildCustomElementConstructor;\nexports.createContextProvider = createContextProvider;\nexports.createElement = createElement;\nexports.freezeTemplate = freezeTemplate;\nexports.getComponentConstructor = getComponentConstructor;\nexports.getComponentDef = getComponentDef;\nexports.hydrateComponent = hydrateComponent;\nexports.isComponentConstructor = isComponentConstructor;\nexports.isNodeFromTemplate = isNodeShadowed;\nexports.parseFragment = parseFragment;\nexports.parseSVGFragment = parseSVGFragment;\nexports.readonly = readonly;\nexports.register = register;\nexports.registerComponent = registerComponent;\nexports.registerDecorators = registerDecorators;\nexports.registerTemplate = registerTemplate;\nexports.renderer = renderer;\nexports.rendererFactory = rendererFactory;\nexports.sanitizeAttribute = sanitizeAttribute;\nexports.setFeatureFlag = setFeatureFlag;\nexports.setFeatureFlagForTest = setFeatureFlagForTest;\nexports.setHooks = setHooks;\nexports.swapComponent = swapComponent;\nexports.swapStyle = swapStyle;\nexports.swapTemplate = swapTemplate;\nexports.track = track;\nexports.unwrap = unwrap;\nexports.wire = wire;\n/* version: 2.38.0 */\n//# sourceMappingURL=engine-dom.cjs.js.map\n\n\n//# sourceURL=webpack://lwc-webpack/./node_modules/@lwc/engine-dom/dist/engine-dom.cjs.js?");

/***/ }),

/***/ "./src/modules/x/app/app.html":
/*!************************************!*\
  !*** ./src/modules/x/app/app.html ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var lwc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lwc */ \"./node_modules/@lwc/engine-dom/dist/engine-dom.cjs.js\");\n/* harmony import */ var _app_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app.css */ \"./node_modules/lwc-webpack-plugin/dist/mocks/empty-style.js\");\n/* harmony import */ var _app_scoped_css_scoped_true__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app.scoped.css?scoped=true */ \"./node_modules/lwc-webpack-plugin/dist/mocks/empty-style.js?scoped=true\");\n\n\n\n\n\n\n\nconst $fragment1 = lwc__WEBPACK_IMPORTED_MODULE_0__.parseFragment`<h1${3}>LWC in Webpack</h1>`;\nconst stc0 = {\n  key: 2\n};\nfunction tmpl($api, $cmp, $slotset, $ctx) {\n  const {st: api_static_fragment, d: api_dynamic_text, t: api_text, h: api_element} = $api;\n  return [api_static_fragment($fragment1(), 1), api_element(\"div\", stc0, [api_text(api_dynamic_text($cmp.helloWorld))])];\n  /*LWC compiler v2.38.0*/\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,lwc__WEBPACK_IMPORTED_MODULE_0__.registerTemplate)(tmpl));\ntmpl.stylesheets = [];\n\n\nif (_app_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n  tmpl.stylesheets.push.apply(tmpl.stylesheets, _app_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n}\nif (_app_scoped_css_scoped_true__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) {\n  tmpl.stylesheets.push.apply(tmpl.stylesheets, _app_scoped_css_scoped_true__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n}\ntmpl.stylesheetToken = \"x-app_app\";\n(0,lwc__WEBPACK_IMPORTED_MODULE_0__.freezeTemplate)(tmpl);\n\n\n//# sourceURL=webpack://lwc-webpack/./src/modules/x/app/app.html?");

/***/ }),

/***/ "./src/modules/x/app/app.js":
/*!**********************************!*\
  !*** ./src/modules/x/app/app.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var lwc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lwc */ \"./node_modules/@lwc/engine-dom/dist/engine-dom.cjs.js\");\n/* harmony import */ var _app_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app.html */ \"./src/modules/x/app/app.html\");\n\n\nclass App extends lwc__WEBPACK_IMPORTED_MODULE_0__.LightningElement {\n  constructor(...args) {\n    super(...args);\n    this.helloWorld = 'Hello, World!!!';\n  }\n  /*LWC compiler v2.38.0*/\n}\n(0,lwc__WEBPACK_IMPORTED_MODULE_0__.registerDecorators)(App, {\n  fields: [\"helloWorld\"]\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,lwc__WEBPACK_IMPORTED_MODULE_0__.registerComponent)(App, {\n  tmpl: _app_html__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n}));\n\n//# sourceURL=webpack://lwc-webpack/./src/modules/x/app/app.js?");

/***/ }),

/***/ "./node_modules/lwc-webpack-plugin/dist/mocks/empty-style.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lwc-webpack-plugin/dist/mocks/empty-style.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nexports.__esModule = true;\n/*\n * Copyright (c) 2022, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nexports[\"default\"] = undefined;\n\n\n//# sourceURL=webpack://lwc-webpack/./node_modules/lwc-webpack-plugin/dist/mocks/empty-style.js?");

/***/ }),

/***/ "./node_modules/lwc-webpack-plugin/dist/mocks/empty-style.js?scoped=true":
/*!*******************************************************************************!*\
  !*** ./node_modules/lwc-webpack-plugin/dist/mocks/empty-style.js?scoped=true ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nexports.__esModule = true;\n/*\n * Copyright (c) 2022, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nexports[\"default\"] = undefined;\n\n\n//# sourceURL=webpack://lwc-webpack/./node_modules/lwc-webpack-plugin/dist/mocks/empty-style.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lwc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lwc */ \"./node_modules/@lwc/engine-dom/dist/engine-dom.cjs.js\");\n/* harmony import */ var x_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! x/app */ \"./src/modules/x/app/app.js\");\n\r\n\r\n\r\nconst elm = (0,lwc__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"x-app\", { is: x_app__WEBPACK_IMPORTED_MODULE_1__[\"default\"] });\r\ndocument.body.appendChild(elm);\r\n\n\n//# sourceURL=webpack://lwc-webpack/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;